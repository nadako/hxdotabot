package dotabot.overrides;

#if macro
import haxe.macro.Compiler;
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Type;
using StringTools;
using haxe.macro.Tools;

class OverrideMacro {
    static function use() {
        var outFile = sys.FileSystem.fullPath(Compiler.getOutput());
        var path = new haxe.io.Path(outFile);
        var outDir = path.dir;
        var module = path.file;

        Context.onGenerate(function(types) {
            // clear the scripts output directory
            deleteRec(outDir);
            sys.FileSystem.createDirectory(outDir);

            // collect script classes
            var scriptClasses = [];

            var completeOverrideMethods = new Map();

            for (type in types) {
                switch (type) {
                    case TInst(_.get() => cl = {pack: ["dotabot", "overrides"], name: "CompleteOverride"}, _):
                        for (field in cl.fields.get())
                            completeOverrideMethods[field.name] = true;

                    case TInst(_.get() => cl = {superClass: {t: _.get() => {pack: ["dotabot", "overrides"], name: baseName}, params: params}}, _):
                        switch (baseName) {
                            case "CompleteOverride":
                                switch (params) {
                                    case [TInst(_.get() => {kind: KExpr({expr: EConst(CString(hero))})}, _)]:
                                        scriptClasses.push({cls: cl, name: 'bot_$hero'});
                                    case _:
                                        throw new Error("Invalid CompleteOverride type parameter, should be string constant", cl.pos);
                                }
                            case unknown:
                                throw new Error("Unknown override base class: " + unknown, cl.pos);
                        }
                    default:
                }
            }

            // no script classes? nothing to do
            if (scriptClasses.length == 0)
                return;

            // generate scripts for our classes
            for (script in scriptClasses) {
                var cl = script.cls;

                // expose the script, so it's visible to generated script
                cl.meta.add(":expose", [], cl.pos);

                // generate the script...
                var b = new StringBuf();

                // add a nice header
                var posStr = Std.string(cl.pos);
                posStr = posStr.substring(5, posStr.length - 1);
                b.add('-- Generated by Haxe, DO NOT EDIT (original source: $posStr)\n\n');

                var dotPath = haxe.macro.MacroStringTools.toDotPath(cl.pack, cl.name);

                // require the main generated lua file
                b.add('local m = require "$module"\n\n');

                // make an instance of script
                b.add('local script = m.$dotPath.new()\n\n');

                // generate callback fields
                for (field in cl.fields.get()) {
                    // this is a callback field, if it's overriden from the base Script class
                    if (completeOverrideMethods.exists(field.name)) {
                        // generate arguments
                        var args = switch (field.type) {
                            case TFun(args, _):
                                [for (arg in args) arg.name].join(", ");
                            default:
                                throw new Error("Overriden class field is not a method. This can't happen! :)", field.pos);
                        }
                        // generate callback function definition
                        b.add('function ${field.name}($args)\n\tscript:${field.name}($args)\nend\n\n');
                    }
                }

                // finally, save the generated script file, using the name of the class
                sys.io.File.saveContent('$outDir/${script.name}.lua', b.toString());
            }
        });
    }

    // this should be in the standard library
    static function deleteRec(path:String) {
        if (!sys.FileSystem.exists(path))
            return;
        if (sys.FileSystem.isDirectory(path)) {
            for (file in sys.FileSystem.readDirectory(path))
                deleteRec('$path/$file');
            sys.FileSystem.deleteDirectory(path);
        } else {
            sys.FileSystem.deleteFile(path);
        }
    }
}
#end
