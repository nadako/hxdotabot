<haxe>
	<class path="Array" params="T" file="/home/travis/haxe/std/lua/_std/Array.hx">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<join public="1" set="method" line="35">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<push public="1" set="method" line="46">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<iterator public="1" get="inline" set="null" line="202">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/home/travis/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="lua.lib.lrexlib.Rex" params="" file="/home/travis/haxe/std/lua/lib/lrexlib/Rex.hx" extern="1">
		<create public="1" get="inline" set="null" line="6" static="1">
			<f a="expr:flag">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.lib.lrexlib.Rex"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<overloads><create public="1" get="inline" set="null" line="6"><f a="expr:flag">
	<c path="String"/>
	<x path="Int"/>
	<c path="lua.lib.lrexlib.Rex"/>
</f></create></overloads>
		</create>
		<match public="1" set="method" static="1">
			<f a="patt:?init:?ef">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>The function searches for the first match of the regexp `patt` in the
	  string `subj`, starting from offset `init`, subject to flags `cf` and `ef`.
    
	  @return matched string, or array of strings.</haxe_doc>
		</match>
		<find public="1" set="method" static="1">
			<f a="subj:?init:?ef">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>The function searches for the first match of the regexp patt in the string
	 `subj`, starting from offset `init`, subject to flags `cf` and `ef`.</haxe_doc>
		</find>
		<split public="1" set="method" static="1">
			<f a="subj:sep:?cf:?ef">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<f a=""><c path="String"/></f>
			</f>
			<haxe_doc>The function is intended for use in the generic for Lua construct. It is
	 used for splitting a subject string `subj` into parts (sections). The `sep`
	 parameter is a regular expression pattern representing separators between
	 the sections.</haxe_doc>
			<overloads><split public="1" set="method">
	<f a="subj:sep:?cf:?ef">
		<c path="String"/>
		<c path="lua.lib.lrexlib.Rex"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=""><c path="String"/></f>
	</f>
	<haxe_doc>The function is intended for use in the generic for Lua construct. It is
	 used for splitting a subject string `subj` into parts (sections). The `sep`
	 parameter is a regular expression pattern representing separators between
	 the sections.</haxe_doc>
</split></overloads>
		</split>
		<count public="1" set="method" static="1">
			<f a="subj:patt:cf:ef">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>This function counts matches of the pattern `patt` in the string `subj`.</haxe_doc>
		</count>
		<flags public="1" set="method" static="1"><f a="?tb">
	<d/>
	<d/>
</f></flags>
		<gmatch public="1" set="method" static="1">
			<f a="subj:?cf:?ef">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>The function is intended for use in the generic for Lua construct. It
	 returns an iterator for repeated matching of the pattern patt in the
	 string `subj`, subject to flags `cf` and `ef`.</haxe_doc>
		</gmatch>
		<gsub public="1" set="method" static="1">
			<f a="subj:patt:repl:?n:?cf:?ef">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>This function searches for all matches of the pattern `patt` in the string 
    `subj` and replaces them according to the parameters `repl` and `n`.</haxe_doc>
			<overloads><gsub public="1" set="method">
	<f a="subj:patt:repl:?n:?cf:?ef">
		<c path="String"/>
		<c path="lua.lib.lrexlib.Rex"/>
		<d/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<c path="String"/>
	</f>
	<haxe_doc>This function searches for all matches of the pattern `patt` in the string 
    `subj` and replaces them according to the parameters `repl` and `n`.</haxe_doc>
</gsub></overloads>
		</gsub>
		<tfind public="1" set="method">
			<f a="subj:?init:?ef">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>The function searches for the first match of the regexp in the string 
    `subj`, starting from offset `init`, subject to execution flags `ef`.</haxe_doc>
		</tfind>
		<exec public="1" set="method">
			<f a="subj:?init:?ef">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>This function searches for the first match of the regexp in the string 
	  `subj`, starting from offset `init`, subject to execution flags `ef`.</haxe_doc>
		</exec>
		<meta><m n=":luaRequire"><e>"rex_pcre"</e></m></meta>
	</class>
	<abstract path="Enum" params="T" file="/home/travis/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/home/travis/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="dotabot.overrides.CompleteOverride" params="HeroName" file="src/dotabot/overrides/CompleteOverride.hx" extern="1">
		<Think public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called every frame in lieu of the normal bot thinking code.</haxe_doc>
		</Think>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Some" params="" file="src/Main.hx" module="Main">
		<extends path="dotabot.overrides.CompleteOverride"><c path="Sgeneric"/></extends>
		<Think public="1" set="method" line="2" override="1"><f a=""><x path="Void"/></f></Think>
	</class>
	<abstract path="Map" params="K:V" file="/home/travis/haxe/std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><t path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</t></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta><m n=":multiType"><e>@:followWithAbstracts K</e></m></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="/home/travis/haxe/std/Map.hx" private="1" module="Map"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<typedef path="IMap" params="K:V" file="/home/travis/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="String" params="" file="/home/travis/haxe/std/lua/_std/String.hx">
		<__oldindex static="1"><c path="lua.Table">
	<d/>
	<d/>
</c></__oldindex>
		<__index set="method" line="37" static="1">
			<f a="s:k">
				<d/>
				<d/>
				<d/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</__index>
		<fromCharCode public="1" get="inline" set="null" line="124" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toString public="1" set="method" line="91">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.
	
	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/home/travis/haxe/std/lua/_std/Std.hx">
		<string public="1" set="method" line="37" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accept or can return a `null` value, or for the Flash compiler and AS3
	generator to distinguish between base values that can be `null` and others that
	can't.

	@see https://haxe.org/manual/types-nullability.html</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<typedef path="dotabot.TODO" params="" file="src/dotabot/Api.hx" module="dotabot.Api"><d/></typedef>
	<typedef path="dotabot.ItemName" params="" file="src/dotabot/Api.hx" module="dotabot.Api"><c path="String"/></typedef>
	<typedef path="dotabot.Vector" params="" file="src/dotabot/Api.hx" module="dotabot.Api"><t path="dotabot.TODO"/></typedef>
	<typedef path="dotabot.Location" params="" file="src/dotabot/Api.hx" module="dotabot.Api"><t path="dotabot.Vector"/></typedef>
	<class path="dotabot.Global" params="" file="src/dotabot/Api.hx" module="dotabot.Api" extern="1">
		<GetBot public="1" set="method" static="1"><f a=""><c path="dotabot.Unit"/></f></GetBot>
		<GetTeam public="1" set="method" static="1"><f a=""><x path="dotabot.Team"/></f></GetTeam>
		<GetTeamMember public="1" set="method" static="1"><f a="team:number">
	<x path="dotabot.Team"/>
	<x path="Int"/>
	<t path="dotabot.TODO"/>
</f></GetTeamMember>
		<DotaTime public="1" set="method" static="1"><f a=""><x path="Float"/></f></DotaTime>
		<GameTime public="1" set="method" static="1"><f a=""><x path="Float"/></f></GameTime>
		<RealTime public="1" set="method" static="1"><f a=""><x path="Float"/></f></RealTime>
		<GetUnitToUnitDistance public="1" set="method" static="1"><f a="a:b">
	<c path="dotabot.Unit"/>
	<c path="dotabot.Unit"/>
	<x path="Float"/>
</f></GetUnitToUnitDistance>
		<GetUnitToLocationDistance public="1" set="method" static="1"><f a="unit:location">
	<c path="dotabot.Unit"/>
	<t path="dotabot.Location"/>
	<x path="Void"/>
</f></GetUnitToLocationDistance>
		<GetWorldBounds public="1" set="method" static="1"><f a=""><x path="Void"/></f></GetWorldBounds>
		<IsLocationPassable public="1" set="method" static="1"><f a=""><x path="Bool"/></f></IsLocationPassable>
		<GetHeightLevel public="1" set="method" static="1"><f a=""><x path="Int"/></f></GetHeightLevel>
		<GetLocationAlongLane public="1" set="method" static="1"><f a=""><x path="Void"/></f></GetLocationAlongLane>
		<GetNeutralSpawners public="1" set="method" static="1"><f a=""><x path="Void"/></f></GetNeutralSpawners>
		<GetItemCost public="1" set="method" static="1"><f a="item">
	<t path="dotabot.ItemName"/>
	<x path="Int"/>
</f></GetItemCost>
		<IsItemPurchasedFromSecretShop public="1" set="method" static="1"><f a="item">
	<t path="dotabot.ItemName"/>
	<x path="Bool"/>
</f></IsItemPurchasedFromSecretShop>
		<IsItemPurchasedFromSideShop public="1" set="method" static="1"><f a="item">
	<t path="dotabot.ItemName"/>
	<x path="Bool"/>
</f></IsItemPurchasedFromSideShop>
		<GetItemStockCount public="1" set="method" static="1"><f a=""><x path="Void"/></f></GetItemStockCount>
		<GetPushLaneDesire public="1" set="method" static="1"><f a=""><x path="Void"/></f></GetPushLaneDesire>
		<GetDefendLaneDesire public="1" set="method" static="1"><f a=""><x path="Void"/></f></GetDefendLaneDesire>
		<GetFarmLaneDesire public="1" set="method" static="1"><f a=""><x path="Void"/></f></GetFarmLaneDesire>
		<GetRoamDesire public="1" set="method" static="1"><f a=""><x path="Void"/></f></GetRoamDesire>
		<GetRoamTarget public="1" set="method" static="1"><f a=""><x path="Void"/></f></GetRoamTarget>
		<GetRoshanDesire public="1" set="method" static="1"><f a=""><x path="Void"/></f></GetRoshanDesire>
		<GetGameState public="1" set="method" static="1"><f a=""><x path="Int"/></f></GetGameState>
		<GetGameStateTimeRemaining public="1" set="method" static="1"><f a=""><x path="Float"/></f></GetGameStateTimeRemaining>
		<GetGameMode public="1" set="method" static="1"><f a=""><x path="Int"/></f></GetGameMode>
		<GetHeroPickState public="1" set="method" static="1"><f a=""><x path="Int"/></f></GetHeroPickState>
		<IsPlayerInHeroSelectionControl public="1" set="method" static="1"><f a=""><x path="Void"/></f></IsPlayerInHeroSelectionControl>
		<SelectHero public="1" set="method" static="1"><f a="player:hero">
	<x path="Int"/>
	<x path="dotabot.HeroName"/>
	<x path="Void"/>
</f></SelectHero>
		<GetSelectedHeroName public="1" set="method" static="1"><f a=""><x path="dotabot.HeroName"/></f></GetSelectedHeroName>
		<IsInCMBanPhase public="1" set="method" static="1"><f a=""><x path="Bool"/></f></IsInCMBanPhase>
		<IsInCMPickPhase public="1" set="method" static="1"><f a=""><x path="Bool"/></f></IsInCMPickPhase>
		<GetCMPhaseTimeRemaining public="1" set="method" static="1"><f a=""><x path="Void"/></f></GetCMPhaseTimeRemaining>
		<GetCMCaptain public="1" set="method" static="1"><f a=""><x path="Void"/></f></GetCMCaptain>
		<SetCMCaptain public="1" set="method" static="1"><f a=""><x path="Void"/></f></SetCMCaptain>
		<IsCMBannedHero public="1" set="method" static="1"><f a="hero">
	<x path="dotabot.HeroName"/>
	<x path="Bool"/>
</f></IsCMBannedHero>
		<IsCMPickedHero public="1" set="method" static="1"><f a="hero">
	<x path="dotabot.HeroName"/>
	<x path="Bool"/>
</f></IsCMPickedHero>
		<CMBanHero public="1" set="method" static="1"><f a="hero">
	<x path="dotabot.HeroName"/>
	<x path="Void"/>
</f></CMBanHero>
		<CMPickHero public="1" set="method" static="1"><f a="hero">
	<x path="dotabot.HeroName"/>
	<x path="Void"/>
</f></CMPickHero>
		<RandomInt public="1" set="method" static="1"><f a="min:max">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></RandomInt>
		<RandomFloat public="1" set="method" static="1"><f a="min:max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></RandomFloat>
		<RandomYawVector public="1" set="method" static="1"><f a=""><x path="Void"/></f></RandomYawVector>
		<RollPercentage public="1" set="method" static="1"><f a=""><x path="Void"/></f></RollPercentage>
		<Min public="1" set="method" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></Min>
		<Max public="1" set="method" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></Max>
		<Clamp public="1" set="method" static="1"><f a="value:min:max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></Clamp>
		<RemapVal public="1" set="method" static="1"><f a=""><x path="Void"/></f></RemapVal>
		<RemapValClamped public="1" set="method" static="1"><f a=""><x path="Void"/></f></RemapValClamped>
		<DebugDrawLine public="1" set="method" static="1"><f a="origin:target:r:g:b:ztest:duration">
	<t path="dotabot.Vector"/>
	<t path="dotabot.Vector"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Void"/>
</f></DebugDrawLine>
		<DebugDrawCircle public="1" set="method" static="1"><f a="center:rgb:a:rad:ztest:duration">
	<t path="dotabot.Vector"/>
	<t path="dotabot.Vector"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Void"/>
</f></DebugDrawCircle>
		<DebugDrawText public="1" set="method" static="1"><f a="origin:text:viewCheck:duration">
	<t path="dotabot.Vector"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Void"/>
</f></DebugDrawText>
		<GetUnitPotentialValue public="1" set="method" static="1"><f a=""><x path="Int"/></f></GetUnitPotentialValue>
		<BOT_ACTION_DESIRE_NONE public="1" set="null" static="1"><x path="Float"/></BOT_ACTION_DESIRE_NONE>
		<BOT_ACTION_DESIRE_VERYLOW public="1" set="null" static="1"><x path="Float"/></BOT_ACTION_DESIRE_VERYLOW>
		<BOT_ACTION_DESIRE_LOW public="1" set="null" static="1"><x path="Float"/></BOT_ACTION_DESIRE_LOW>
		<BOT_ACTION_DESIRE_MODERATE public="1" set="null" static="1"><x path="Float"/></BOT_ACTION_DESIRE_MODERATE>
		<BOT_ACTION_DESIRE_HIGH public="1" set="null" static="1"><x path="Float"/></BOT_ACTION_DESIRE_HIGH>
		<BOT_ACTION_DESIRE_VERYHIGH public="1" set="null" static="1"><x path="Float"/></BOT_ACTION_DESIRE_VERYHIGH>
		<BOT_ACTION_DESIRE_ABSOLUTE public="1" set="null" static="1"><x path="Float"/></BOT_ACTION_DESIRE_ABSOLUTE>
		<BOT_MODE_DESIRE_NONE public="1" set="null" static="1"><x path="Float"/></BOT_MODE_DESIRE_NONE>
		<BOT_MODE_DESIRE_VERYLOW public="1" set="null" static="1"><x path="Float"/></BOT_MODE_DESIRE_VERYLOW>
		<BOT_MODE_DESIRE_LOW public="1" set="null" static="1"><x path="Float"/></BOT_MODE_DESIRE_LOW>
		<BOT_MODE_DESIRE_MODERATE public="1" set="null" static="1"><x path="Float"/></BOT_MODE_DESIRE_MODERATE>
		<BOT_MODE_DESIRE_HIGH public="1" set="null" static="1"><x path="Float"/></BOT_MODE_DESIRE_HIGH>
		<BOT_MODE_DESIRE_VERYHIGH public="1" set="null" static="1"><x path="Float"/></BOT_MODE_DESIRE_VERYHIGH>
		<BOT_MODE_DESIRE_ABSOLUTE public="1" set="null" static="1"><x path="Float"/></BOT_MODE_DESIRE_ABSOLUTE>
		<meta><m n=":native"><e>"_G"</e></m></meta>
	</class>
	<class path="dotabot.Unit" params="" file="src/dotabot/Api.hx" module="dotabot.Api" extern="1">
		<Action_ClearActions public="1" set="method"><f a=""><x path="Void"/></f></Action_ClearActions>
		<Action_MoveToLocation public="1" set="method"><f a=""><x path="Void"/></f></Action_MoveToLocation>
		<Action_MoveToUnit public="1" set="method"><f a=""><x path="Void"/></f></Action_MoveToUnit>
		<Action_AttackUnit public="1" set="method"><f a=""><x path="Void"/></f></Action_AttackUnit>
		<Action_AttackMove public="1" set="method"><f a=""><x path="Void"/></f></Action_AttackMove>
		<Action_UseAbility public="1" set="method"><f a="ability">
	<c path="dotabot.Ability"/>
	<x path="Void"/>
</f></Action_UseAbility>
		<Action_UseAbilityOnEntity public="1" set="method"><f a="ability:entity">
	<c path="dotabot.Ability"/>
	<c path="dotabot.Unit"/>
	<x path="Void"/>
</f></Action_UseAbilityOnEntity>
		<Action_UseAbilityOnLocation public="1" set="method"><f a="ability:location">
	<c path="dotabot.Ability"/>
	<t path="dotabot.Location"/>
	<x path="Void"/>
</f></Action_UseAbilityOnLocation>
		<Action_UseAbilityOnTree public="1" set="method"><f a="ability:tree">
	<c path="dotabot.Ability"/>
	<c path="dotabot.Unit"/>
	<x path="Void"/>
</f></Action_UseAbilityOnTree>
		<Action_PickUpRune public="1" set="method"><f a=""><x path="Void"/></f></Action_PickUpRune>
		<Action_PickUpItem public="1" set="method"><f a=""><x path="Void"/></f></Action_PickUpItem>
		<Action_DropItem public="1" set="method"><f a=""><x path="Void"/></f></Action_DropItem>
		<Action_PurchaseItem public="1" set="method"><f a="item">
	<t path="dotabot.ItemName"/>
	<x path="dotabot.ItemPurchaseResult"/>
</f></Action_PurchaseItem>
		<Action_SellItem public="1" set="method"><f a=""><x path="Void"/></f></Action_SellItem>
		<Action_Buyback public="1" set="method"><f a=""><x path="Void"/></f></Action_Buyback>
		<Action_LevelAbility public="1" set="method"><f a=""><x path="Void"/></f></Action_LevelAbility>
		<GetDifficulty public="1" set="method"><f a=""><x path="dotabot.Difficulty"/></f></GetDifficulty>
		<GetUnitName public="1" set="method"><f a=""><c path="String"/></f></GetUnitName>
		<GetPlayer public="1" set="method"><f a=""><x path="Void"/></f></GetPlayer>
		<IsHero public="1" set="method"><f a=""><x path="Bool"/></f></IsHero>
		<IsCreep public="1" set="method"><f a=""><x path="Bool"/></f></IsCreep>
		<IsTower public="1" set="method"><f a=""><x path="Bool"/></f></IsTower>
		<IsBuilding public="1" set="method"><f a=""><x path="Bool"/></f></IsBuilding>
		<IsFort public="1" set="method"><f a=""><x path="Bool"/></f></IsFort>
		<IsIllusion public="1" set="method"><f a=""><x path="Bool"/></f></IsIllusion>
		<CanBeSeen public="1" set="method"><f a=""><x path="Bool"/></f></CanBeSeen>
		<GetActiveMode public="1" set="method"><f a=""><x path="dotabot.BotMode"/></f></GetActiveMode>
		<GetActiveModeDesire public="1" set="method"><f a=""><x path="Float"/></f></GetActiveModeDesire>
		<GetHealth public="1" set="method"><f a=""><x path="Int"/></f></GetHealth>
		<GetMaxHealth public="1" set="method"><f a=""><x path="Int"/></f></GetMaxHealth>
		<GetMana public="1" set="method"><f a=""><x path="Int"/></f></GetMana>
		<GetMaxMana public="1" set="method"><f a=""><x path="Int"/></f></GetMaxMana>
		<IsAlive public="1" set="method"><f a=""><x path="Bool"/></f></IsAlive>
		<GetRespawnTime public="1" set="method"><f a=""><x path="Void"/></f></GetRespawnTime>
		<HasBuyback public="1" set="method"><f a=""><x path="Void"/></f></HasBuyback>
		<GetGold public="1" set="method"><f a=""><x path="Int"/></f></GetGold>
		<GetStashValue public="1" set="method"><f a=""><x path="Void"/></f></GetStashValue>
		<GetCourierValue public="1" set="method"><f a=""><x path="Void"/></f></GetCourierValue>
		<GetLocation public="1" set="method"><f a=""><t path="dotabot.Location"/></f></GetLocation>
		<GetFacing public="1" set="method"><f a=""><x path="Void"/></f></GetFacing>
		<GetGroundHeight public="1" set="method"><f a=""><x path="Void"/></f></GetGroundHeight>
		<GetAbilityByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="dotabot.Ability"/>
</f></GetAbilityByName>
		<GetItemInSlot public="1" set="method"><f a=""><x path="Void"/></f></GetItemInSlot>
		<IsChanneling public="1" set="method"><f a=""><x path="Bool"/></f></IsChanneling>
		<IsUsingAbility public="1" set="method"><f a=""><x path="Bool"/></f></IsUsingAbility>
		<GetVelocity public="1" set="method"><f a=""><x path="Void"/></f></GetVelocity>
		<GetAttackTarget public="1" set="method"><f a=""><c path="dotabot.Unit"/></f></GetAttackTarget>
		<GetLastSeenLocation public="1" set="method"><f a=""><x path="Void"/></f></GetLastSeenLocation>
		<GetTimeSinceLastSeen public="1" set="method"><f a=""><x path="Void"/></f></GetTimeSinceLastSeen>
		<IsRooted public="1" set="method"><f a=""><x path="Bool"/></f></IsRooted>
		<IsDisarmed public="1" set="method"><f a=""><x path="Bool"/></f></IsDisarmed>
		<IsAttackImmune public="1" set="method"><f a=""><x path="Bool"/></f></IsAttackImmune>
		<IsSilenced public="1" set="method"><f a=""><x path="Bool"/></f></IsSilenced>
		<IsMuted public="1" set="method"><f a=""><x path="Bool"/></f></IsMuted>
		<IsStunned public="1" set="method"><f a=""><x path="Bool"/></f></IsStunned>
		<IsHexed public="1" set="method"><f a=""><x path="Bool"/></f></IsHexed>
		<IsInvulnerable public="1" set="method"><f a=""><x path="Bool"/></f></IsInvulnerable>
		<IsMagicImmune public="1" set="method"><f a=""><x path="Bool"/></f></IsMagicImmune>
		<IsNightmared public="1" set="method"><f a=""><x path="Bool"/></f></IsNightmared>
		<IsBlockDisabled public="1" set="method"><f a=""><x path="Bool"/></f></IsBlockDisabled>
		<IsEvadeDisabled public="1" set="method"><f a=""><x path="Bool"/></f></IsEvadeDisabled>
		<IsUnableToMiss public="1" set="method"><f a=""><x path="Bool"/></f></IsUnableToMiss>
		<IsSpeciallyDeniable public="1" set="method"><f a=""><x path="Bool"/></f></IsSpeciallyDeniable>
		<IsDominated public="1" set="method"><f a=""><x path="Bool"/></f></IsDominated>
		<IsBlind public="1" set="method"><f a=""><x path="Bool"/></f></IsBlind>
		<HasScepter public="1" set="method"><f a=""><x path="Bool"/></f></HasScepter>
		<WasRecentlyDamagedByAnyHero public="1" set="method"><f a=""><x path="Bool"/></f></WasRecentlyDamagedByAnyHero>
		<WasRecentlyDamagedByHero public="1" set="method"><f a=""><x path="Bool"/></f></WasRecentlyDamagedByHero>
		<TimeSinceDamagedByAnyHero public="1" set="method"><f a=""><x path="Void"/></f></TimeSinceDamagedByAnyHero>
		<TimeSinceDamagedByHero public="1" set="method"><f a=""><x path="Void"/></f></TimeSinceDamagedByHero>
		<DistanceFromFountain public="1" set="method"><f a=""><x path="Void"/></f></DistanceFromFountain>
		<DistanceFromSideShop public="1" set="method"><f a=""><x path="Void"/></f></DistanceFromSideShop>
		<DistanceFromSecretShop public="1" set="method"><f a=""><x path="Void"/></f></DistanceFromSecretShop>
		<SetTarget public="1" set="method"><f a="target">
	<c path="dotabot.Unit"/>
	<x path="Void"/>
</f></SetTarget>
		<GetTarget public="1" set="method"><f a=""><t path="Null"><c path="dotabot.Unit"/></t></f></GetTarget>
		<SetNextItemPurchaseValue public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></SetNextItemPurchaseValue>
		<GetNextItemPurchaseValue public="1" set="method"><f a=""><x path="Int"/></f></GetNextItemPurchaseValue>
		<GetAssignedLane public="1" set="method"><f a=""><x path="Void"/></f></GetAssignedLane>
		<GetEstimatedDamageToTarget public="1" set="method"><f a=""><x path="Float"/></f></GetEstimatedDamageToTarget>
		<GetStunDuration public="1" set="method"><f a=""><x path="Void"/></f></GetStunDuration>
		<GetSlowDuration public="1" set="method"><f a=""><x path="Void"/></f></GetSlowDuration>
		<HasBlink public="1" set="method"><f a=""><x path="Void"/></f></HasBlink>
		<HasMinistunOnAttack public="1" set="method"><f a=""><x path="Void"/></f></HasMinistunOnAttack>
		<HasSilence public="1" set="method"><f a=""><x path="Void"/></f></HasSilence>
		<HasInvisibility public="1" set="method"><f a=""><x path="Void"/></f></HasInvisibility>
		<UsingItemBreaksInvisibility public="1" set="method"><f a=""><x path="Void"/></f></UsingItemBreaksInvisibility>
		<GetNearbyHeroes public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="dotabot.Unit"/>
</c></f></GetNearbyHeroes>
		<GetNearbyTowers public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="dotabot.Unit"/>
</c></f></GetNearbyTowers>
		<GetNearbyCreeps public="1" set="method"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="dotabot.Unit"/>
</c></f></GetNearbyCreeps>
		<FindAoELocation public="1" set="method"><f a=""><x path="Void"/></f></FindAoELocation>
		<GetExtrapolatedLocation public="1" set="method"><f a=""><x path="Void"/></f></GetExtrapolatedLocation>
		<GetMovementDirectionStability public="1" set="method"><f a=""><x path="Void"/></f></GetMovementDirectionStability>
		<GetActualDamage public="1" set="method"><f a=""><x path="Void"/></f></GetActualDamage>
	</class>
	<abstract path="dotabot.GameMode" params="" file="src/dotabot/Api.hx" module="dotabot.Api">
		<this><x path="Int"/></this>
		<meta>
			<m n=":native"><e>"_G"</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="dotabot._Api.GameMode_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
	<GAMEMODE_NONE public="1" set="null" static="1">
		<x path="dotabot.GameMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAMEMODE_NONE>
	<GAMEMODE_AP public="1" set="null" static="1">
		<x path="dotabot.GameMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAMEMODE_AP>
	<GAMEMODE_CM public="1" set="null" static="1">
		<x path="dotabot.GameMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAMEMODE_CM>
	<GAMEMODE_RD public="1" set="null" static="1">
		<x path="dotabot.GameMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAMEMODE_RD>
	<GAMEMODE_SD public="1" set="null" static="1">
		<x path="dotabot.GameMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAMEMODE_SD>
	<GAMEMODE_AR public="1" set="null" static="1">
		<x path="dotabot.GameMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAMEMODE_AR>
	<GAMEMODE_REVERSE_CM public="1" set="null" static="1">
		<x path="dotabot.GameMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAMEMODE_REVERSE_CM>
	<GAMEMODE_MO public="1" set="null" static="1">
		<x path="dotabot.GameMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAMEMODE_MO>
	<GAMEMODE_CD public="1" set="null" static="1">
		<x path="dotabot.GameMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAMEMODE_CD>
	<GAMEMODE_ABILITY_DRAFT public="1" set="null" static="1">
		<x path="dotabot.GameMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAMEMODE_ABILITY_DRAFT>
	<GAMEMODE_ARDM public="1" set="null" static="1">
		<x path="dotabot.GameMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAMEMODE_ARDM>
	<GAMEMODE_1V1MID public="1" set="null" static="1">
		<x path="dotabot.GameMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAMEMODE_1V1MID>
	<GAMEMODE_ALL_DRAFT public="1" set="null" static="1">
		<x path="dotabot.GameMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAMEMODE_ALL_DRAFT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":native"><e>"_G"</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="dotabot._Api.GameMode_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
		<GAMEMODE_NONE public="1" set="null" static="1">
			<x path="dotabot.GameMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAMEMODE_NONE>
		<GAMEMODE_AP public="1" set="null" static="1">
			<x path="dotabot.GameMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAMEMODE_AP>
		<GAMEMODE_CM public="1" set="null" static="1">
			<x path="dotabot.GameMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAMEMODE_CM>
		<GAMEMODE_RD public="1" set="null" static="1">
			<x path="dotabot.GameMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAMEMODE_RD>
		<GAMEMODE_SD public="1" set="null" static="1">
			<x path="dotabot.GameMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAMEMODE_SD>
		<GAMEMODE_AR public="1" set="null" static="1">
			<x path="dotabot.GameMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAMEMODE_AR>
		<GAMEMODE_REVERSE_CM public="1" set="null" static="1">
			<x path="dotabot.GameMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAMEMODE_REVERSE_CM>
		<GAMEMODE_MO public="1" set="null" static="1">
			<x path="dotabot.GameMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAMEMODE_MO>
		<GAMEMODE_CD public="1" set="null" static="1">
			<x path="dotabot.GameMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAMEMODE_CD>
		<GAMEMODE_ABILITY_DRAFT public="1" set="null" static="1">
			<x path="dotabot.GameMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAMEMODE_ABILITY_DRAFT>
		<GAMEMODE_ARDM public="1" set="null" static="1">
			<x path="dotabot.GameMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAMEMODE_ARDM>
		<GAMEMODE_1V1MID public="1" set="null" static="1">
			<x path="dotabot.GameMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAMEMODE_1V1MID>
		<GAMEMODE_ALL_DRAFT public="1" set="null" static="1">
			<x path="dotabot.GameMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAMEMODE_ALL_DRAFT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<abstract path="dotabot.BotMode" params="" file="src/dotabot/Api.hx" module="dotabot.Api">
		<this><x path="Int"/></this>
		<meta>
			<m n=":native"><e>"_G"</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="dotabot._Api.BotMode_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
	<BOT_MODE_NONE public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_NONE>
	<BOT_MODE_LANING public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_LANING>
	<BOT_MODE_ATTACK public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_ATTACK>
	<BOT_MODE_ROAM public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_ROAM>
	<BOT_MODE_RETREAT public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_RETREAT>
	<BOT_MODE_SECRET_SHOP public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_SECRET_SHOP>
	<BOT_MODE_SIDE_SHOP public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_SIDE_SHOP>
	<BOT_MODE_PUSH_TOWER_TOP public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_PUSH_TOWER_TOP>
	<BOT_MODE_PUSH_TOWER_MID public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_PUSH_TOWER_MID>
	<BOT_MODE_PUSH_TOWER_BOT public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_PUSH_TOWER_BOT>
	<BOT_MODE_DEFEND_TOWER_TOP public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_DEFEND_TOWER_TOP>
	<BOT_MODE_DEFEND_TOWER_MID public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_DEFEND_TOWER_MID>
	<BOT_MODE_DEFEND_TOWER_BOT public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_DEFEND_TOWER_BOT>
	<BOT_MODE_ASSEMBLE public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_ASSEMBLE>
	<BOT_MODE_TEAM_ROAM public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_TEAM_ROAM>
	<BOT_MODE_FARM public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_FARM>
	<BOT_MODE_DEFEND_ALLY public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_DEFEND_ALLY>
	<BOT_MODE_EVASIVE_MANEUVERS public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_EVASIVE_MANEUVERS>
	<BOT_MODE_ROSHAN public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_ROSHAN>
	<BOT_MODE_ITEM public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_ITEM>
	<BOT_MODE_WARD public="1" set="null" static="1">
		<x path="dotabot.BotMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOT_MODE_WARD>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":native"><e>"_G"</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="dotabot._Api.BotMode_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
		<BOT_MODE_NONE public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_NONE>
		<BOT_MODE_LANING public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_LANING>
		<BOT_MODE_ATTACK public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_ATTACK>
		<BOT_MODE_ROAM public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_ROAM>
		<BOT_MODE_RETREAT public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_RETREAT>
		<BOT_MODE_SECRET_SHOP public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_SECRET_SHOP>
		<BOT_MODE_SIDE_SHOP public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_SIDE_SHOP>
		<BOT_MODE_PUSH_TOWER_TOP public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_PUSH_TOWER_TOP>
		<BOT_MODE_PUSH_TOWER_MID public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_PUSH_TOWER_MID>
		<BOT_MODE_PUSH_TOWER_BOT public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_PUSH_TOWER_BOT>
		<BOT_MODE_DEFEND_TOWER_TOP public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_DEFEND_TOWER_TOP>
		<BOT_MODE_DEFEND_TOWER_MID public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_DEFEND_TOWER_MID>
		<BOT_MODE_DEFEND_TOWER_BOT public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_DEFEND_TOWER_BOT>
		<BOT_MODE_ASSEMBLE public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_ASSEMBLE>
		<BOT_MODE_TEAM_ROAM public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_TEAM_ROAM>
		<BOT_MODE_FARM public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_FARM>
		<BOT_MODE_DEFEND_ALLY public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_DEFEND_ALLY>
		<BOT_MODE_EVASIVE_MANEUVERS public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_EVASIVE_MANEUVERS>
		<BOT_MODE_ROSHAN public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_ROSHAN>
		<BOT_MODE_ITEM public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_ITEM>
		<BOT_MODE_WARD public="1" set="null" static="1">
			<x path="dotabot.BotMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOT_MODE_WARD>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<abstract path="dotabot.DamageType" params="" file="src/dotabot/Api.hx" module="dotabot.Api">
		<this><x path="Int"/></this>
		<meta>
			<m n=":native"><e>"_G"</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="dotabot._Api.DamageType_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
	<DAMAGE_TYPE_PHYSICAL public="1" set="null" static="1">
		<x path="dotabot.DamageType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DAMAGE_TYPE_PHYSICAL>
	<DAMAGE_TYPE_MAGICAL public="1" set="null" static="1">
		<x path="dotabot.DamageType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DAMAGE_TYPE_MAGICAL>
	<DAMAGE_TYPE_PURE public="1" set="null" static="1">
		<x path="dotabot.DamageType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DAMAGE_TYPE_PURE>
	<DAMAGE_TYPE_ALL public="1" set="null" static="1">
		<x path="dotabot.DamageType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DAMAGE_TYPE_ALL>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":native"><e>"_G"</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="dotabot._Api.DamageType_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
		<DAMAGE_TYPE_PHYSICAL public="1" set="null" static="1">
			<x path="dotabot.DamageType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DAMAGE_TYPE_PHYSICAL>
		<DAMAGE_TYPE_MAGICAL public="1" set="null" static="1">
			<x path="dotabot.DamageType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DAMAGE_TYPE_MAGICAL>
		<DAMAGE_TYPE_PURE public="1" set="null" static="1">
			<x path="dotabot.DamageType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DAMAGE_TYPE_PURE>
		<DAMAGE_TYPE_ALL public="1" set="null" static="1">
			<x path="dotabot.DamageType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DAMAGE_TYPE_ALL>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<abstract path="dotabot.Difficulty" params="" file="src/dotabot/Api.hx" module="dotabot.Api">
		<this><x path="Int"/></this>
		<meta>
			<m n=":native"><e>"_G"</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="dotabot._Api.Difficulty_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
	<DIFFICULTY_INVALID public="1" set="null" static="1">
		<x path="dotabot.Difficulty"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DIFFICULTY_INVALID>
	<DIFFICULTY_PASSIVE public="1" set="null" static="1">
		<x path="dotabot.Difficulty"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DIFFICULTY_PASSIVE>
	<DIFFICULTY_EASY public="1" set="null" static="1">
		<x path="dotabot.Difficulty"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DIFFICULTY_EASY>
	<DIFFICULTY_MEDIUM public="1" set="null" static="1">
		<x path="dotabot.Difficulty"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DIFFICULTY_MEDIUM>
	<DIFFICULTY_HARD public="1" set="null" static="1">
		<x path="dotabot.Difficulty"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DIFFICULTY_HARD>
	<DIFFICULTY_UNFAIR public="1" set="null" static="1">
		<x path="dotabot.Difficulty"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DIFFICULTY_UNFAIR>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":native"><e>"_G"</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="dotabot._Api.Difficulty_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
		<DIFFICULTY_INVALID public="1" set="null" static="1">
			<x path="dotabot.Difficulty"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DIFFICULTY_INVALID>
		<DIFFICULTY_PASSIVE public="1" set="null" static="1">
			<x path="dotabot.Difficulty"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DIFFICULTY_PASSIVE>
		<DIFFICULTY_EASY public="1" set="null" static="1">
			<x path="dotabot.Difficulty"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DIFFICULTY_EASY>
		<DIFFICULTY_MEDIUM public="1" set="null" static="1">
			<x path="dotabot.Difficulty"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DIFFICULTY_MEDIUM>
		<DIFFICULTY_HARD public="1" set="null" static="1">
			<x path="dotabot.Difficulty"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DIFFICULTY_HARD>
		<DIFFICULTY_UNFAIR public="1" set="null" static="1">
			<x path="dotabot.Difficulty"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DIFFICULTY_UNFAIR>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<abstract path="dotabot.ItemPurchaseResult" params="" file="src/dotabot/Api.hx" module="dotabot.Api">
		<this><x path="Int"/></this>
		<meta>
			<m n=":native"><e>"_G"</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="dotabot._Api.ItemPurchaseResult_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
	<PURCHASE_ITEM_SUCCESS public="1" set="null" static="1">
		<x path="dotabot.ItemPurchaseResult"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PURCHASE_ITEM_SUCCESS>
	<PURCHASE_ITEM_OUT_OF_STOCK public="1" set="null" static="1">
		<x path="dotabot.ItemPurchaseResult"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PURCHASE_ITEM_OUT_OF_STOCK>
	<PURCHASE_ITEM_DISALLOWED_ITEM public="1" set="null" static="1">
		<x path="dotabot.ItemPurchaseResult"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PURCHASE_ITEM_DISALLOWED_ITEM>
	<PURCHASE_ITEM_INSUFFICIENT_GOLD public="1" set="null" static="1">
		<x path="dotabot.ItemPurchaseResult"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PURCHASE_ITEM_INSUFFICIENT_GOLD>
	<PURCHASE_ITEM_NOT_AT_HOME_SHOP public="1" set="null" static="1">
		<x path="dotabot.ItemPurchaseResult"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PURCHASE_ITEM_NOT_AT_HOME_SHOP>
	<PURCHASE_ITEM_NOT_AT_SIDE_SHOP public="1" set="null" static="1">
		<x path="dotabot.ItemPurchaseResult"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PURCHASE_ITEM_NOT_AT_SIDE_SHOP>
	<PURCHASE_ITEM_NOT_AT_SECRET_SHOP public="1" set="null" static="1">
		<x path="dotabot.ItemPurchaseResult"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PURCHASE_ITEM_NOT_AT_SECRET_SHOP>
	<PURCHASE_ITEM_INVALID_ITEM_NAME public="1" set="null" static="1">
		<x path="dotabot.ItemPurchaseResult"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PURCHASE_ITEM_INVALID_ITEM_NAME>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":native"><e>"_G"</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="dotabot._Api.ItemPurchaseResult_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
		<PURCHASE_ITEM_SUCCESS public="1" set="null" static="1">
			<x path="dotabot.ItemPurchaseResult"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PURCHASE_ITEM_SUCCESS>
		<PURCHASE_ITEM_OUT_OF_STOCK public="1" set="null" static="1">
			<x path="dotabot.ItemPurchaseResult"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PURCHASE_ITEM_OUT_OF_STOCK>
		<PURCHASE_ITEM_DISALLOWED_ITEM public="1" set="null" static="1">
			<x path="dotabot.ItemPurchaseResult"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PURCHASE_ITEM_DISALLOWED_ITEM>
		<PURCHASE_ITEM_INSUFFICIENT_GOLD public="1" set="null" static="1">
			<x path="dotabot.ItemPurchaseResult"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PURCHASE_ITEM_INSUFFICIENT_GOLD>
		<PURCHASE_ITEM_NOT_AT_HOME_SHOP public="1" set="null" static="1">
			<x path="dotabot.ItemPurchaseResult"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PURCHASE_ITEM_NOT_AT_HOME_SHOP>
		<PURCHASE_ITEM_NOT_AT_SIDE_SHOP public="1" set="null" static="1">
			<x path="dotabot.ItemPurchaseResult"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PURCHASE_ITEM_NOT_AT_SIDE_SHOP>
		<PURCHASE_ITEM_NOT_AT_SECRET_SHOP public="1" set="null" static="1">
			<x path="dotabot.ItemPurchaseResult"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PURCHASE_ITEM_NOT_AT_SECRET_SHOP>
		<PURCHASE_ITEM_INVALID_ITEM_NAME public="1" set="null" static="1">
			<x path="dotabot.ItemPurchaseResult"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PURCHASE_ITEM_INVALID_ITEM_NAME>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<abstract path="dotabot.Team" params="" file="src/dotabot/Api.hx" module="dotabot.Api">
		<this><x path="Int"/></this>
		<meta>
			<m n=":native"><e>"_G"</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="dotabot._Api.Team_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
	<TEAM_RADIANT public="1" set="null" static="1">
		<x path="dotabot.Team"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEAM_RADIANT>
	<TEAM_DIRE public="1" set="null" static="1">
		<x path="dotabot.Team"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEAM_DIRE>
	<TEAM_NEUTRAL public="1" set="null" static="1">
		<x path="dotabot.Team"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEAM_NEUTRAL>
	<TEAM_NONE public="1" set="null" static="1">
		<x path="dotabot.Team"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEAM_NONE>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":native"><e>"_G"</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="dotabot._Api.Team_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
		<TEAM_RADIANT public="1" set="null" static="1">
			<x path="dotabot.Team"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEAM_RADIANT>
		<TEAM_DIRE public="1" set="null" static="1">
			<x path="dotabot.Team"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEAM_DIRE>
		<TEAM_NEUTRAL public="1" set="null" static="1">
			<x path="dotabot.Team"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEAM_NEUTRAL>
		<TEAM_NONE public="1" set="null" static="1">
			<x path="dotabot.Team"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEAM_NONE>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<abstract path="dotabot.GameState" params="" file="src/dotabot/Api.hx" module="dotabot.Api">
		<this><x path="Int"/></this>
		<meta>
			<m n=":native"><e>"_G"</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="dotabot._Api.GameState_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
	<GAME_STATE_INIT public="1" set="null" static="1">
		<x path="dotabot.GameState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAME_STATE_INIT>
	<GAME_STATE_WAIT_FOR_PLAYERS_TO_LOAD public="1" set="null" static="1">
		<x path="dotabot.GameState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAME_STATE_WAIT_FOR_PLAYERS_TO_LOAD>
	<GAME_STATE_HERO_SELECTION public="1" set="null" static="1">
		<x path="dotabot.GameState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAME_STATE_HERO_SELECTION>
	<GAME_STATE_STRATEGY_TIME public="1" set="null" static="1">
		<x path="dotabot.GameState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAME_STATE_STRATEGY_TIME>
	<GAME_STATE_PRE_GAME public="1" set="null" static="1">
		<x path="dotabot.GameState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAME_STATE_PRE_GAME>
	<GAME_STATE_GAME_IN_PROGRESS public="1" set="null" static="1">
		<x path="dotabot.GameState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAME_STATE_GAME_IN_PROGRESS>
	<GAME_STATE_POST_GAME public="1" set="null" static="1">
		<x path="dotabot.GameState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAME_STATE_POST_GAME>
	<GAME_STATE_DISCONNECT public="1" set="null" static="1">
		<x path="dotabot.GameState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAME_STATE_DISCONNECT>
	<GAME_STATE_TEAM_SHOWCASE public="1" set="null" static="1">
		<x path="dotabot.GameState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAME_STATE_TEAM_SHOWCASE>
	<GAME_STATE_CUSTOM_GAME_SETUP public="1" set="null" static="1">
		<x path="dotabot.GameState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAME_STATE_CUSTOM_GAME_SETUP>
	<GAME_STATE_WAIT_FOR_MAP_TO_LOAD public="1" set="null" static="1">
		<x path="dotabot.GameState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAME_STATE_WAIT_FOR_MAP_TO_LOAD>
	<GAME_STATE_LAST public="1" set="null" static="1">
		<x path="dotabot.GameState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAME_STATE_LAST>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":native"><e>"_G"</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="dotabot._Api.GameState_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
		<GAME_STATE_INIT public="1" set="null" static="1">
			<x path="dotabot.GameState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAME_STATE_INIT>
		<GAME_STATE_WAIT_FOR_PLAYERS_TO_LOAD public="1" set="null" static="1">
			<x path="dotabot.GameState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAME_STATE_WAIT_FOR_PLAYERS_TO_LOAD>
		<GAME_STATE_HERO_SELECTION public="1" set="null" static="1">
			<x path="dotabot.GameState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAME_STATE_HERO_SELECTION>
		<GAME_STATE_STRATEGY_TIME public="1" set="null" static="1">
			<x path="dotabot.GameState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAME_STATE_STRATEGY_TIME>
		<GAME_STATE_PRE_GAME public="1" set="null" static="1">
			<x path="dotabot.GameState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAME_STATE_PRE_GAME>
		<GAME_STATE_GAME_IN_PROGRESS public="1" set="null" static="1">
			<x path="dotabot.GameState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAME_STATE_GAME_IN_PROGRESS>
		<GAME_STATE_POST_GAME public="1" set="null" static="1">
			<x path="dotabot.GameState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAME_STATE_POST_GAME>
		<GAME_STATE_DISCONNECT public="1" set="null" static="1">
			<x path="dotabot.GameState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAME_STATE_DISCONNECT>
		<GAME_STATE_TEAM_SHOWCASE public="1" set="null" static="1">
			<x path="dotabot.GameState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAME_STATE_TEAM_SHOWCASE>
		<GAME_STATE_CUSTOM_GAME_SETUP public="1" set="null" static="1">
			<x path="dotabot.GameState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAME_STATE_CUSTOM_GAME_SETUP>
		<GAME_STATE_WAIT_FOR_MAP_TO_LOAD public="1" set="null" static="1">
			<x path="dotabot.GameState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAME_STATE_WAIT_FOR_MAP_TO_LOAD>
		<GAME_STATE_LAST public="1" set="null" static="1">
			<x path="dotabot.GameState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAME_STATE_LAST>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<abstract path="dotabot.HeroPickState" params="" file="src/dotabot/Api.hx" module="dotabot.Api">
		<this><x path="Int"/></this>
		<meta>
			<m n=":native"><e>"_G"</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="dotabot._Api.HeroPickState_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
	<HEROPICK_STATE_NONE public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_NONE>
	<HEROPICK_STATE_AP_SELECT public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_AP_SELECT>
	<HEROPICK_STATE_SD_SELECT public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_SD_SELECT>
	<HEROPICK_STATE_CM_INTRO public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_INTRO>
	<HEROPICK_STATE_CM_CAPTAINPICK public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_CAPTAINPICK>
	<HEROPICK_STATE_CM_BAN1 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_BAN1>
	<HEROPICK_STATE_CM_BAN2 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_BAN2>
	<HEROPICK_STATE_CM_BAN3 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_BAN3>
	<HEROPICK_STATE_CM_BAN4 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_BAN4>
	<HEROPICK_STATE_CM_BAN5 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_BAN5>
	<HEROPICK_STATE_CM_BAN6 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_BAN6>
	<HEROPICK_STATE_CM_BAN7 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_BAN7>
	<HEROPICK_STATE_CM_BAN8 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_BAN8>
	<HEROPICK_STATE_CM_BAN9 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_BAN9>
	<HEROPICK_STATE_CM_BAN10 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_BAN10>
	<HEROPICK_STATE_CM_SELECT1 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_SELECT1>
	<HEROPICK_STATE_CM_SELECT2 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_SELECT2>
	<HEROPICK_STATE_CM_SELECT3 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_SELECT3>
	<HEROPICK_STATE_CM_SELECT4 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_SELECT4>
	<HEROPICK_STATE_CM_SELECT5 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_SELECT5>
	<HEROPICK_STATE_CM_SELECT6 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_SELECT6>
	<HEROPICK_STATE_CM_SELECT7 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_SELECT7>
	<HEROPICK_STATE_CM_SELECT8 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_SELECT8>
	<HEROPICK_STATE_CM_SELECT9 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_SELECT9>
	<HEROPICK_STATE_CM_SELECT10 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_SELECT10>
	<HEROPICK_STATE_CM_PICK public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CM_PICK>
	<HEROPICK_STATE_AR_SELECT public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_AR_SELECT>
	<HEROPICK_STATE_MO_SELECT public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_MO_SELECT>
	<HEROPICK_STATE_FH_SELECT public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_FH_SELECT>
	<HEROPICK_STATE_CD_INTRO public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_INTRO>
	<HEROPICK_STATE_CD_CAPTAINPICK public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_CAPTAINPICK>
	<HEROPICK_STATE_CD_BAN1 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_BAN1>
	<HEROPICK_STATE_CD_BAN2 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_BAN2>
	<HEROPICK_STATE_CD_BAN3 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_BAN3>
	<HEROPICK_STATE_CD_BAN4 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_BAN4>
	<HEROPICK_STATE_CD_BAN5 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_BAN5>
	<HEROPICK_STATE_CD_BAN6 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_BAN6>
	<HEROPICK_STATE_CD_SELECT1 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_SELECT1>
	<HEROPICK_STATE_CD_SELECT2 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_SELECT2>
	<HEROPICK_STATE_CD_SELECT3 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_SELECT3>
	<HEROPICK_STATE_CD_SELECT4 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_SELECT4>
	<HEROPICK_STATE_CD_SELECT5 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_SELECT5>
	<HEROPICK_STATE_CD_SELECT6 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_SELECT6>
	<HEROPICK_STATE_CD_SELECT7 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_SELECT7>
	<HEROPICK_STATE_CD_SELECT8 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_SELECT8>
	<HEROPICK_STATE_CD_SELECT9 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_SELECT9>
	<HEROPICK_STATE_CD_SELECT10 public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_SELECT10>
	<HEROPICK_STATE_CD_PICK public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_CD_PICK>
	<HEROPICK_STATE_BD_SELECT public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_BD_SELECT>
	<HERO_PICK_STATE_ABILITY_DRAFT_SELECT public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HERO_PICK_STATE_ABILITY_DRAFT_SELECT>
	<HERO_PICK_STATE_ARDM_SELECT public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HERO_PICK_STATE_ARDM_SELECT>
	<HEROPICK_STATE_ALL_DRAFT_SELECT public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_ALL_DRAFT_SELECT>
	<HERO_PICK_STATE_CUSTOMGAME_SELECT public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HERO_PICK_STATE_CUSTOMGAME_SELECT>
	<HEROPICK_STATE_SELECT_PENALTY public="1" set="null" static="1">
		<x path="dotabot.HeroPickState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEROPICK_STATE_SELECT_PENALTY>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":native"><e>"_G"</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="dotabot._Api.HeroPickState_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
		<HEROPICK_STATE_NONE public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_NONE>
		<HEROPICK_STATE_AP_SELECT public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_AP_SELECT>
		<HEROPICK_STATE_SD_SELECT public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_SD_SELECT>
		<HEROPICK_STATE_CM_INTRO public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_INTRO>
		<HEROPICK_STATE_CM_CAPTAINPICK public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_CAPTAINPICK>
		<HEROPICK_STATE_CM_BAN1 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_BAN1>
		<HEROPICK_STATE_CM_BAN2 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_BAN2>
		<HEROPICK_STATE_CM_BAN3 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_BAN3>
		<HEROPICK_STATE_CM_BAN4 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_BAN4>
		<HEROPICK_STATE_CM_BAN5 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_BAN5>
		<HEROPICK_STATE_CM_BAN6 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_BAN6>
		<HEROPICK_STATE_CM_BAN7 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_BAN7>
		<HEROPICK_STATE_CM_BAN8 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_BAN8>
		<HEROPICK_STATE_CM_BAN9 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_BAN9>
		<HEROPICK_STATE_CM_BAN10 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_BAN10>
		<HEROPICK_STATE_CM_SELECT1 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_SELECT1>
		<HEROPICK_STATE_CM_SELECT2 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_SELECT2>
		<HEROPICK_STATE_CM_SELECT3 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_SELECT3>
		<HEROPICK_STATE_CM_SELECT4 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_SELECT4>
		<HEROPICK_STATE_CM_SELECT5 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_SELECT5>
		<HEROPICK_STATE_CM_SELECT6 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_SELECT6>
		<HEROPICK_STATE_CM_SELECT7 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_SELECT7>
		<HEROPICK_STATE_CM_SELECT8 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_SELECT8>
		<HEROPICK_STATE_CM_SELECT9 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_SELECT9>
		<HEROPICK_STATE_CM_SELECT10 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_SELECT10>
		<HEROPICK_STATE_CM_PICK public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CM_PICK>
		<HEROPICK_STATE_AR_SELECT public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_AR_SELECT>
		<HEROPICK_STATE_MO_SELECT public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_MO_SELECT>
		<HEROPICK_STATE_FH_SELECT public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_FH_SELECT>
		<HEROPICK_STATE_CD_INTRO public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_INTRO>
		<HEROPICK_STATE_CD_CAPTAINPICK public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_CAPTAINPICK>
		<HEROPICK_STATE_CD_BAN1 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_BAN1>
		<HEROPICK_STATE_CD_BAN2 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_BAN2>
		<HEROPICK_STATE_CD_BAN3 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_BAN3>
		<HEROPICK_STATE_CD_BAN4 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_BAN4>
		<HEROPICK_STATE_CD_BAN5 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_BAN5>
		<HEROPICK_STATE_CD_BAN6 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_BAN6>
		<HEROPICK_STATE_CD_SELECT1 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_SELECT1>
		<HEROPICK_STATE_CD_SELECT2 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_SELECT2>
		<HEROPICK_STATE_CD_SELECT3 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_SELECT3>
		<HEROPICK_STATE_CD_SELECT4 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_SELECT4>
		<HEROPICK_STATE_CD_SELECT5 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_SELECT5>
		<HEROPICK_STATE_CD_SELECT6 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_SELECT6>
		<HEROPICK_STATE_CD_SELECT7 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_SELECT7>
		<HEROPICK_STATE_CD_SELECT8 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_SELECT8>
		<HEROPICK_STATE_CD_SELECT9 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_SELECT9>
		<HEROPICK_STATE_CD_SELECT10 public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_SELECT10>
		<HEROPICK_STATE_CD_PICK public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_CD_PICK>
		<HEROPICK_STATE_BD_SELECT public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_BD_SELECT>
		<HERO_PICK_STATE_ABILITY_DRAFT_SELECT public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HERO_PICK_STATE_ABILITY_DRAFT_SELECT>
		<HERO_PICK_STATE_ARDM_SELECT public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HERO_PICK_STATE_ARDM_SELECT>
		<HEROPICK_STATE_ALL_DRAFT_SELECT public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_ALL_DRAFT_SELECT>
		<HERO_PICK_STATE_CUSTOMGAME_SELECT public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HERO_PICK_STATE_CUSTOMGAME_SELECT>
		<HEROPICK_STATE_SELECT_PENALTY public="1" set="null" static="1">
			<x path="dotabot.HeroPickState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEROPICK_STATE_SELECT_PENALTY>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<abstract path="dotabot.Rune" params="" file="src/dotabot/Api.hx" module="dotabot.Api">
		<this><x path="Int"/></this>
		<meta>
			<m n=":native"><e>"_G"</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="dotabot._Api.Rune_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
	<RUNE_DOUBLEDAMAGE public="1" set="null" static="1">
		<x path="dotabot.Rune"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RUNE_DOUBLEDAMAGE>
	<RUNE_HASTE public="1" set="null" static="1">
		<x path="dotabot.Rune"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RUNE_HASTE>
	<RUNE_ILLUSION public="1" set="null" static="1">
		<x path="dotabot.Rune"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RUNE_ILLUSION>
	<RUNE_INVISIBILITY public="1" set="null" static="1">
		<x path="dotabot.Rune"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RUNE_INVISIBILITY>
	<RUNE_REGENERATION public="1" set="null" static="1">
		<x path="dotabot.Rune"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RUNE_REGENERATION>
	<RUNE_BOUNTY public="1" set="null" static="1">
		<x path="dotabot.Rune"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RUNE_BOUNTY>
	<RUNE_ARCANE public="1" set="null" static="1">
		<x path="dotabot.Rune"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RUNE_ARCANE>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":native"><e>"_G"</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="dotabot._Api.Rune_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
		<RUNE_DOUBLEDAMAGE public="1" set="null" static="1">
			<x path="dotabot.Rune"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RUNE_DOUBLEDAMAGE>
		<RUNE_HASTE public="1" set="null" static="1">
			<x path="dotabot.Rune"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RUNE_HASTE>
		<RUNE_ILLUSION public="1" set="null" static="1">
			<x path="dotabot.Rune"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RUNE_ILLUSION>
		<RUNE_INVISIBILITY public="1" set="null" static="1">
			<x path="dotabot.Rune"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RUNE_INVISIBILITY>
		<RUNE_REGENERATION public="1" set="null" static="1">
			<x path="dotabot.Rune"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RUNE_REGENERATION>
		<RUNE_BOUNTY public="1" set="null" static="1">
			<x path="dotabot.Rune"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RUNE_BOUNTY>
		<RUNE_ARCANE public="1" set="null" static="1">
			<x path="dotabot.Rune"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RUNE_ARCANE>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<abstract path="dotabot.RuneStatus" params="" file="src/dotabot/Api.hx" module="dotabot.Api">
		<this><x path="Int"/></this>
		<meta>
			<m n=":native"><e>"_G"</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="dotabot._Api.RuneStatus_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
	<RUNE_STATUS_UNKNOWN public="1" set="null" static="1">
		<x path="dotabot.RuneStatus"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RUNE_STATUS_UNKNOWN>
	<RUNE_STATUS_AVAILABLE public="1" set="null" static="1">
		<x path="dotabot.RuneStatus"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RUNE_STATUS_AVAILABLE>
	<RUNE_STATUS_MISSING public="1" set="null" static="1">
		<x path="dotabot.RuneStatus"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RUNE_STATUS_MISSING>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":native"><e>"_G"</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="dotabot._Api.RuneStatus_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
		<RUNE_STATUS_UNKNOWN public="1" set="null" static="1">
			<x path="dotabot.RuneStatus"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RUNE_STATUS_UNKNOWN>
		<RUNE_STATUS_AVAILABLE public="1" set="null" static="1">
			<x path="dotabot.RuneStatus"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RUNE_STATUS_AVAILABLE>
		<RUNE_STATUS_MISSING public="1" set="null" static="1">
			<x path="dotabot.RuneStatus"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RUNE_STATUS_MISSING>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<class path="dotabot.Ability" params="" file="src/dotabot/Api.hx" module="dotabot.Api" extern="1">
		<IsFullyCastable public="1" set="method"><f a=""><x path="Bool"/></f></IsFullyCastable>
		<GetCastRange public="1" set="method"><f a=""><x path="Int"/></f></GetCastRange>
		<GetAbilityDamage public="1" set="method"><f a=""><x path="Int"/></f></GetAbilityDamage>
	</class>
	<abstract path="dotabot.HeroName" params="" file="src/dotabot/Api.hx" module="dotabot.Api">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="dotabot._Api.HeroName_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
	<Abaddon public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_abaddon&quot;" line="360" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_abaddon"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Abaddon>
	<Alchemist public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_alchemist&quot;" line="361" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_alchemist"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Alchemist>
	<AncientApparition public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_ancient_apparition&quot;" line="362" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_ancient_apparition"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AncientApparition>
	<Antimage public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_antimage&quot;" line="363" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_antimage"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Antimage>
	<Axe public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_axe&quot;" line="364" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_axe"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Axe>
	<Bane public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_bane&quot;" line="365" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_bane"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Bane>
	<Batrider public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_batrider&quot;" line="366" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_batrider"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Batrider>
	<Beastmaster public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_beastmaster&quot;" line="367" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_beastmaster"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Beastmaster>
	<Bloodseeker public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_bloodseeker&quot;" line="368" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_bloodseeker"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Bloodseeker>
	<BountyHunter public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_bounty_hunter&quot;" line="369" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_bounty_hunter"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BountyHunter>
	<Brewmaster public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_brewmaster&quot;" line="370" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_brewmaster"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Brewmaster>
	<Bristleback public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_bristleback&quot;" line="371" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_bristleback"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Bristleback>
	<Broodmother public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_broodmother&quot;" line="372" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_broodmother"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Broodmother>
	<Centaur public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_centaur&quot;" line="373" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_centaur"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Centaur>
	<ChaosKnight public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_chaos_knight&quot;" line="374" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_chaos_knight"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ChaosKnight>
	<Chen public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_chen&quot;" line="375" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_chen"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Chen>
	<Clinkz public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_clinkz&quot;" line="376" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_clinkz"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Clinkz>
	<CrystalMaiden public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_crystal_maiden&quot;" line="377" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_crystal_maiden"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CrystalMaiden>
	<DarkSeer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_dark_seer&quot;" line="378" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_dark_seer"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DarkSeer>
	<Dazzle public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_dazzle&quot;" line="379" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_dazzle"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Dazzle>
	<DeathProphet public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_death_prophet&quot;" line="380" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_death_prophet"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DeathProphet>
	<Disruptor public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_disruptor&quot;" line="381" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_disruptor"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Disruptor>
	<DoomBringer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_doom_bringer&quot;" line="382" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_doom_bringer"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DoomBringer>
	<DragonKnight public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_dragon_knight&quot;" line="383" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_dragon_knight"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DragonKnight>
	<DrowRanger public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_drow_ranger&quot;" line="384" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_drow_ranger"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DrowRanger>
	<EarthSpirit public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_earth_spirit&quot;" line="385" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_earth_spirit"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EarthSpirit>
	<Earthshaker public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_earthshaker&quot;" line="386" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_earthshaker"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Earthshaker>
	<ElderTitan public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_elder_titan&quot;" line="387" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_elder_titan"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ElderTitan>
	<EmberSpirit public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_ember_spirit&quot;" line="388" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_ember_spirit"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EmberSpirit>
	<Enchantress public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_enchantress&quot;" line="389" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_enchantress"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Enchantress>
	<Enigma public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_enigma&quot;" line="390" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_enigma"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Enigma>
	<FacelessVoid public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_faceless_void&quot;" line="391" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_faceless_void"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FacelessVoid>
	<Furion public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_furion&quot;" line="392" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_furion"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Furion>
	<Gyrocopter public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_gyrocopter&quot;" line="393" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_gyrocopter"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Gyrocopter>
	<Huskar public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_huskar&quot;" line="394" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_huskar"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Huskar>
	<Invoker public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_invoker&quot;" line="395" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_invoker"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Invoker>
	<Jakiro public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_jakiro&quot;" line="396" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_jakiro"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Jakiro>
	<Juggernaut public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_juggernaut&quot;" line="397" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_juggernaut"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Juggernaut>
	<KeeperOfTheLight public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_keeper_of_the_light&quot;" line="398" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_keeper_of_the_light"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KeeperOfTheLight>
	<Kunkka public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_kunkka&quot;" line="399" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_kunkka"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Kunkka>
	<LegionCommander public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_legion_commander&quot;" line="400" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_legion_commander"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LegionCommander>
	<Leshrac public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_leshrac&quot;" line="401" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_leshrac"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Leshrac>
	<Lich public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_lich&quot;" line="402" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_lich"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Lich>
	<LifeStealer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_life_stealer&quot;" line="403" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_life_stealer"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LifeStealer>
	<Lina public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_lina&quot;" line="404" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_lina"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Lina>
	<Lion public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_lion&quot;" line="405" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_lion"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Lion>
	<LoneDruid public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_lone_druid&quot;" line="406" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_lone_druid"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LoneDruid>
	<Luna public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_luna&quot;" line="407" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_luna"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Luna>
	<Lycan public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_lycan&quot;" line="408" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_lycan"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Lycan>
	<Magnataur public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_magnataur&quot;" line="409" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_magnataur"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Magnataur>
	<Medusa public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_medusa&quot;" line="410" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_medusa"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Medusa>
	<Meepo public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_meepo&quot;" line="411" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_meepo"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Meepo>
	<Mirana public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_mirana&quot;" line="412" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_mirana"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Mirana>
	<Morphling public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_morphling&quot;" line="413" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_morphling"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Morphling>
	<NagaSiren public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_naga_siren&quot;" line="414" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_naga_siren"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NagaSiren>
	<Necrolyte public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_necrolyte&quot;" line="415" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_necrolyte"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Necrolyte>
	<Nevermore public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_nevermore&quot;" line="416" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_nevermore"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Nevermore>
	<NightStalker public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_night_stalker&quot;" line="417" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_night_stalker"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NightStalker>
	<NyxAssassin public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_nyx_assassin&quot;" line="418" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_nyx_assassin"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NyxAssassin>
	<ObsidianDestroyer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_obsidian_destroyer&quot;" line="419" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_obsidian_destroyer"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ObsidianDestroyer>
	<OgreMagi public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_ogre_magi&quot;" line="420" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_ogre_magi"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OgreMagi>
	<Omniknight public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_omniknight&quot;" line="421" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_omniknight"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Omniknight>
	<PhantomAssassin public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_phantom_assassin&quot;" line="422" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_phantom_assassin"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PhantomAssassin>
	<PhantomLancer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_phantom_lancer&quot;" line="423" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_phantom_lancer"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PhantomLancer>
	<Phoenix public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_phoenix&quot;" line="424" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_phoenix"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Phoenix>
	<Puck public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_puck&quot;" line="425" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_puck"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Puck>
	<Pudge public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_pudge&quot;" line="426" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_pudge"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Pudge>
	<Pugna public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_pugna&quot;" line="427" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_pugna"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Pugna>
	<Queenofpain public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_queenofpain&quot;" line="428" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_queenofpain"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Queenofpain>
	<Rattletrap public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_rattletrap&quot;" line="429" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_rattletrap"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Rattletrap>
	<Razor public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_razor&quot;" line="430" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_razor"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Razor>
	<Riki public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_riki&quot;" line="431" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_riki"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Riki>
	<Rubick public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_rubick&quot;" line="432" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_rubick"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Rubick>
	<SandKing public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_sand_king&quot;" line="433" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_sand_king"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SandKing>
	<ShadowDemon public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_shadow_demon&quot;" line="434" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_shadow_demon"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ShadowDemon>
	<ShadowShaman public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_shadow_shaman&quot;" line="435" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_shadow_shaman"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ShadowShaman>
	<Shredder public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_shredder&quot;" line="436" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_shredder"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Shredder>
	<Silencer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_silencer&quot;" line="437" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_silencer"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Silencer>
	<SkeletonKing public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_skeleton_king&quot;" line="438" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_skeleton_king"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SkeletonKing>
	<SkywrathMage public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_skywrath_mage&quot;" line="439" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_skywrath_mage"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SkywrathMage>
	<Slardar public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_slardar&quot;" line="440" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_slardar"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Slardar>
	<Slark public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_slark&quot;" line="441" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_slark"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Slark>
	<Sniper public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_sniper&quot;" line="442" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_sniper"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Sniper>
	<Spectre public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_spectre&quot;" line="443" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_spectre"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Spectre>
	<SpiritBreaker public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_spirit_breaker&quot;" line="444" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_spirit_breaker"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SpiritBreaker>
	<StormSpirit public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_storm_spirit&quot;" line="445" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_storm_spirit"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</StormSpirit>
	<Sven public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_sven&quot;" line="446" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_sven"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Sven>
	<TemplarAssassin public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_templar_assassin&quot;" line="447" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_templar_assassin"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TemplarAssassin>
	<Terrorblade public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_terrorblade&quot;" line="448" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_terrorblade"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Terrorblade>
	<Tidehunter public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_tidehunter&quot;" line="449" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_tidehunter"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Tidehunter>
	<Tinker public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_tinker&quot;" line="450" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_tinker"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Tinker>
	<Tiny public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_tiny&quot;" line="451" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_tiny"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Tiny>
	<Treant public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_treant&quot;" line="452" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_treant"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Treant>
	<TrollWarlord public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_troll_warlord&quot;" line="453" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_troll_warlord"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TrollWarlord>
	<Tusk public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_tusk&quot;" line="454" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_tusk"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Tusk>
	<Undying public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_undying&quot;" line="455" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_undying"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Undying>
	<Ursa public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_ursa&quot;" line="456" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_ursa"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Ursa>
	<Vengefulspirit public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_vengefulspirit&quot;" line="457" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_vengefulspirit"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Vengefulspirit>
	<Venomancer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_venomancer&quot;" line="458" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_venomancer"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Venomancer>
	<Viper public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_viper&quot;" line="459" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_viper"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Viper>
	<Visage public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_visage&quot;" line="460" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_visage"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Visage>
	<Warlock public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_warlock&quot;" line="461" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_warlock"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Warlock>
	<Weaver public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_weaver&quot;" line="462" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_weaver"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Weaver>
	<Windrunner public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_windrunner&quot;" line="463" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_windrunner"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Windrunner>
	<Wisp public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_wisp&quot;" line="464" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_wisp"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Wisp>
	<WitchDoctor public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_witch_doctor&quot;" line="465" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_witch_doctor"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WitchDoctor>
	<Zuus public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_zuus&quot;" line="466" static="1">
		<x path="dotabot.HeroName"/>
		<meta>
			<m n=":value"><e>cast "npc_dota_hero_zuus"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Zuus>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="dotabot._Api.HeroName_Impl_" params="" file="src/dotabot/Api.hx" private="1" module="dotabot.Api" extern="1">
		<Abaddon public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_abaddon&quot;" line="360" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_abaddon"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Abaddon>
		<Alchemist public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_alchemist&quot;" line="361" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_alchemist"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Alchemist>
		<AncientApparition public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_ancient_apparition&quot;" line="362" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_ancient_apparition"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AncientApparition>
		<Antimage public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_antimage&quot;" line="363" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_antimage"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Antimage>
		<Axe public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_axe&quot;" line="364" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_axe"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Axe>
		<Bane public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_bane&quot;" line="365" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_bane"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Bane>
		<Batrider public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_batrider&quot;" line="366" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_batrider"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Batrider>
		<Beastmaster public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_beastmaster&quot;" line="367" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_beastmaster"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Beastmaster>
		<Bloodseeker public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_bloodseeker&quot;" line="368" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_bloodseeker"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Bloodseeker>
		<BountyHunter public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_bounty_hunter&quot;" line="369" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_bounty_hunter"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BountyHunter>
		<Brewmaster public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_brewmaster&quot;" line="370" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_brewmaster"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Brewmaster>
		<Bristleback public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_bristleback&quot;" line="371" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_bristleback"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Bristleback>
		<Broodmother public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_broodmother&quot;" line="372" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_broodmother"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Broodmother>
		<Centaur public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_centaur&quot;" line="373" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_centaur"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Centaur>
		<ChaosKnight public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_chaos_knight&quot;" line="374" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_chaos_knight"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ChaosKnight>
		<Chen public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_chen&quot;" line="375" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_chen"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Chen>
		<Clinkz public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_clinkz&quot;" line="376" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_clinkz"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Clinkz>
		<CrystalMaiden public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_crystal_maiden&quot;" line="377" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_crystal_maiden"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CrystalMaiden>
		<DarkSeer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_dark_seer&quot;" line="378" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_dark_seer"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DarkSeer>
		<Dazzle public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_dazzle&quot;" line="379" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_dazzle"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Dazzle>
		<DeathProphet public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_death_prophet&quot;" line="380" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_death_prophet"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DeathProphet>
		<Disruptor public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_disruptor&quot;" line="381" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_disruptor"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Disruptor>
		<DoomBringer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_doom_bringer&quot;" line="382" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_doom_bringer"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DoomBringer>
		<DragonKnight public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_dragon_knight&quot;" line="383" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_dragon_knight"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DragonKnight>
		<DrowRanger public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_drow_ranger&quot;" line="384" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_drow_ranger"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DrowRanger>
		<EarthSpirit public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_earth_spirit&quot;" line="385" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_earth_spirit"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EarthSpirit>
		<Earthshaker public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_earthshaker&quot;" line="386" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_earthshaker"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Earthshaker>
		<ElderTitan public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_elder_titan&quot;" line="387" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_elder_titan"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ElderTitan>
		<EmberSpirit public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_ember_spirit&quot;" line="388" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_ember_spirit"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EmberSpirit>
		<Enchantress public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_enchantress&quot;" line="389" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_enchantress"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Enchantress>
		<Enigma public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_enigma&quot;" line="390" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_enigma"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Enigma>
		<FacelessVoid public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_faceless_void&quot;" line="391" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_faceless_void"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FacelessVoid>
		<Furion public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_furion&quot;" line="392" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_furion"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Furion>
		<Gyrocopter public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_gyrocopter&quot;" line="393" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_gyrocopter"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Gyrocopter>
		<Huskar public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_huskar&quot;" line="394" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_huskar"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Huskar>
		<Invoker public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_invoker&quot;" line="395" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_invoker"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Invoker>
		<Jakiro public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_jakiro&quot;" line="396" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_jakiro"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Jakiro>
		<Juggernaut public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_juggernaut&quot;" line="397" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_juggernaut"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Juggernaut>
		<KeeperOfTheLight public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_keeper_of_the_light&quot;" line="398" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_keeper_of_the_light"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KeeperOfTheLight>
		<Kunkka public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_kunkka&quot;" line="399" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_kunkka"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Kunkka>
		<LegionCommander public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_legion_commander&quot;" line="400" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_legion_commander"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LegionCommander>
		<Leshrac public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_leshrac&quot;" line="401" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_leshrac"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Leshrac>
		<Lich public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_lich&quot;" line="402" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_lich"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Lich>
		<LifeStealer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_life_stealer&quot;" line="403" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_life_stealer"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LifeStealer>
		<Lina public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_lina&quot;" line="404" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_lina"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Lina>
		<Lion public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_lion&quot;" line="405" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_lion"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Lion>
		<LoneDruid public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_lone_druid&quot;" line="406" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_lone_druid"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LoneDruid>
		<Luna public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_luna&quot;" line="407" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_luna"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Luna>
		<Lycan public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_lycan&quot;" line="408" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_lycan"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Lycan>
		<Magnataur public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_magnataur&quot;" line="409" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_magnataur"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Magnataur>
		<Medusa public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_medusa&quot;" line="410" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_medusa"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Medusa>
		<Meepo public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_meepo&quot;" line="411" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_meepo"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Meepo>
		<Mirana public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_mirana&quot;" line="412" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_mirana"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Mirana>
		<Morphling public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_morphling&quot;" line="413" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_morphling"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Morphling>
		<NagaSiren public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_naga_siren&quot;" line="414" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_naga_siren"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NagaSiren>
		<Necrolyte public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_necrolyte&quot;" line="415" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_necrolyte"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Necrolyte>
		<Nevermore public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_nevermore&quot;" line="416" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_nevermore"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Nevermore>
		<NightStalker public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_night_stalker&quot;" line="417" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_night_stalker"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NightStalker>
		<NyxAssassin public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_nyx_assassin&quot;" line="418" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_nyx_assassin"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NyxAssassin>
		<ObsidianDestroyer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_obsidian_destroyer&quot;" line="419" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_obsidian_destroyer"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ObsidianDestroyer>
		<OgreMagi public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_ogre_magi&quot;" line="420" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_ogre_magi"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OgreMagi>
		<Omniknight public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_omniknight&quot;" line="421" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_omniknight"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Omniknight>
		<PhantomAssassin public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_phantom_assassin&quot;" line="422" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_phantom_assassin"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PhantomAssassin>
		<PhantomLancer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_phantom_lancer&quot;" line="423" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_phantom_lancer"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PhantomLancer>
		<Phoenix public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_phoenix&quot;" line="424" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_phoenix"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Phoenix>
		<Puck public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_puck&quot;" line="425" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_puck"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Puck>
		<Pudge public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_pudge&quot;" line="426" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_pudge"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Pudge>
		<Pugna public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_pugna&quot;" line="427" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_pugna"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Pugna>
		<Queenofpain public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_queenofpain&quot;" line="428" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_queenofpain"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Queenofpain>
		<Rattletrap public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_rattletrap&quot;" line="429" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_rattletrap"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Rattletrap>
		<Razor public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_razor&quot;" line="430" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_razor"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Razor>
		<Riki public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_riki&quot;" line="431" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_riki"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Riki>
		<Rubick public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_rubick&quot;" line="432" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_rubick"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Rubick>
		<SandKing public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_sand_king&quot;" line="433" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_sand_king"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SandKing>
		<ShadowDemon public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_shadow_demon&quot;" line="434" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_shadow_demon"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ShadowDemon>
		<ShadowShaman public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_shadow_shaman&quot;" line="435" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_shadow_shaman"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ShadowShaman>
		<Shredder public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_shredder&quot;" line="436" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_shredder"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Shredder>
		<Silencer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_silencer&quot;" line="437" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_silencer"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Silencer>
		<SkeletonKing public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_skeleton_king&quot;" line="438" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_skeleton_king"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SkeletonKing>
		<SkywrathMage public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_skywrath_mage&quot;" line="439" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_skywrath_mage"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SkywrathMage>
		<Slardar public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_slardar&quot;" line="440" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_slardar"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Slardar>
		<Slark public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_slark&quot;" line="441" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_slark"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Slark>
		<Sniper public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_sniper&quot;" line="442" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_sniper"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Sniper>
		<Spectre public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_spectre&quot;" line="443" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_spectre"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Spectre>
		<SpiritBreaker public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_spirit_breaker&quot;" line="444" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_spirit_breaker"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SpiritBreaker>
		<StormSpirit public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_storm_spirit&quot;" line="445" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_storm_spirit"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</StormSpirit>
		<Sven public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_sven&quot;" line="446" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_sven"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Sven>
		<TemplarAssassin public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_templar_assassin&quot;" line="447" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_templar_assassin"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TemplarAssassin>
		<Terrorblade public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_terrorblade&quot;" line="448" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_terrorblade"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Terrorblade>
		<Tidehunter public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_tidehunter&quot;" line="449" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_tidehunter"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Tidehunter>
		<Tinker public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_tinker&quot;" line="450" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_tinker"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Tinker>
		<Tiny public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_tiny&quot;" line="451" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_tiny"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Tiny>
		<Treant public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_treant&quot;" line="452" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_treant"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Treant>
		<TrollWarlord public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_troll_warlord&quot;" line="453" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_troll_warlord"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TrollWarlord>
		<Tusk public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_tusk&quot;" line="454" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_tusk"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Tusk>
		<Undying public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_undying&quot;" line="455" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_undying"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Undying>
		<Ursa public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_ursa&quot;" line="456" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_ursa"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Ursa>
		<Vengefulspirit public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_vengefulspirit&quot;" line="457" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_vengefulspirit"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Vengefulspirit>
		<Venomancer public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_venomancer&quot;" line="458" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_venomancer"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Venomancer>
		<Viper public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_viper&quot;" line="459" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_viper"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Viper>
		<Visage public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_visage&quot;" line="460" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_visage"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Visage>
		<Warlock public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_warlock&quot;" line="461" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_warlock"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Warlock>
		<Weaver public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_weaver&quot;" line="462" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_weaver"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Weaver>
		<Windrunner public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_windrunner&quot;" line="463" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_windrunner"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Windrunner>
		<Wisp public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_wisp&quot;" line="464" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_wisp"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Wisp>
		<WitchDoctor public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_witch_doctor&quot;" line="465" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_witch_doctor"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WitchDoctor>
		<Zuus public="1" get="inline" set="null" expr="cast &quot;npc_dota_hero_zuus&quot;" line="466" static="1">
			<x path="dotabot.HeroName"/>
			<meta>
				<m n=":value"><e>cast "npc_dota_hero_zuus"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Zuus>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="dotabot.Lane" params="" file="src/dotabot/Lane.hx">
		<this><x path="Int"/></this>
		<meta>
			<m n=":native"><e>"_G"</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="dotabot._Lane.Lane_Impl_" params="" file="src/dotabot/Lane.hx" private="1" module="dotabot.Lane" extern="1">
	<LANE_NONE public="1" set="null" static="1">
		<x path="dotabot.Lane"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LANE_NONE>
	<LANE_TOP public="1" set="null" static="1">
		<x path="dotabot.Lane"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LANE_TOP>
	<LANE_MID public="1" set="null" static="1">
		<x path="dotabot.Lane"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LANE_MID>
	<LANE_BOT public="1" set="null" static="1">
		<x path="dotabot.Lane"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LANE_BOT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":native"><e>"_G"</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="dotabot._Lane.Lane_Impl_" params="" file="src/dotabot/Lane.hx" private="1" module="dotabot.Lane" extern="1">
		<LANE_NONE public="1" set="null" static="1">
			<x path="dotabot.Lane"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LANE_NONE>
		<LANE_TOP public="1" set="null" static="1">
			<x path="dotabot.Lane"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LANE_TOP>
		<LANE_MID public="1" set="null" static="1">
			<x path="dotabot.Lane"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LANE_MID>
		<LANE_BOT public="1" set="null" static="1">
			<x path="dotabot.Lane"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LANE_BOT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<class path="dotabot.overrides.AbilityItemUsageOverride" params="HeroName" file="src/dotabot/overrides/AbilityItemUsageOverride.hx" extern="1">
		<ItemUsageThink public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called every frame. Responsible for issuing item usage actions.</haxe_doc>
		</ItemUsageThink>
		<AbilityUsageThink public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called every frame. Responsible for issuing ability usage actions.</haxe_doc>
		</AbilityUsageThink>
		<CourierUsageThink public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called every frame. Responsible for issuing commands to the courier.</haxe_doc>
		</CourierUsageThink>
		<BuybackUsageThink public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called every frame. Responsible for issuing a command to buyback.</haxe_doc>
		</BuybackUsageThink>
	</class>
	<class path="dotabot.overrides.HeroSelectionOverride" params="" file="src/dotabot/overrides/HeroSelectionOverride.hx" extern="1">
		<Think public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called every frame. Responsible for selecting heroes for bots.</haxe_doc>
		</Think>
		<UpdateLaneAssignments public="1" set="method">
			<f a=""><c path="lua.Table">
	<x path="Int"/>
	<x path="dotabot.Lane"/>
</c></f>
			<haxe_doc>Called every frame prior to the game starting. Returns ten PlayerID-Lane pairs</haxe_doc>
		</UpdateLaneAssignments>
	</class>
	<class path="dotabot.overrides.ItemPurchaseOverride" params="HeroName" file="src/dotabot/overrides/ItemPurchaseOverride.hx" extern="1"><ItemPurchaseThink public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>Called every frame. Responsible for purchasing items.</haxe_doc>
</ItemPurchaseThink></class>
	<class path="dotabot.overrides.ModeOverride" params="Mode:HeroName" file="src/dotabot/overrides/ModeOverride.hx" extern="1">
		<GetDesire public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Called every frame, and needs to return a floating-point value between 0 and 1 that indicates how much this mode wants to be the active mode.</haxe_doc>
		</GetDesire>
		<OnStart public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a mode takes control as the active mode.</haxe_doc>
		</OnStart>
		<OnEnd public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a mode relinquishes control to another active mode.</haxe_doc>
		</OnEnd>
		<Think public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called every frame while this is the active mode. Responsible for issuing actions for the bot to take.</haxe_doc>
		</Think>
	</class>
	<class path="dotabot.overrides.TeamDesiresOverride" params="" file="src/dotabot/overrides/TeamDesiresOverride.hx" extern="1">
		<UpdatePushLaneDesires public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Called every frame. Returns floating point values between 0 and 1 that represent the desires for pushing the top, middle, and bottom lanes, respectively.</haxe_doc>
		</UpdatePushLaneDesires>
		<UpdateDefendLaneDesires public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Called every frame. Returns floating point values between 0 and 1 that represent the desires for defending the top, middle, and bottom lanes, respectively.</haxe_doc>
		</UpdateDefendLaneDesires>
		<UpdateFarmLaneDesires public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Called every frame. Returns floating point values between 0 and 1 that represent the desires for farming the top, middle, and bottom lanes, respectively.</haxe_doc>
		</UpdateFarmLaneDesires>
		<UpdateRoamDesire public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Called every frame. Returns a floating point value between 0 and 1 and a unit handle that represents the desire for someone to roam and gank a specified target.</haxe_doc>
		</UpdateRoamDesire>
		<UpdateRoshanDesire public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Called every frame. Returns a floating point value between 0 and 1 that represents the desire for the team to kill Roshan.</haxe_doc>
		</UpdateRoshanDesire>
	</class>
	<abstract path="haxe.Function" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which
		* is public and
		* unifies with the type used for type parameter `T`.

	If a type parameter A is assigned to a type parameter B which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="/home/travis/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="50" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="63" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="79" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="96" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="108" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an 
  [extension](https://haxe.org/manual/lf-static-extension.html) to the 
  `enum` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/home/travis/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="132" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="143" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="157" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="169" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<match public="1" set="method" static="1">
			<f a="e:pattern">
				<x path="EnumValue"/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Matches enum instance `e` against pattern `pattern`, returning `true` if
		matching succeeded and `false` otherwise.

		Example usage:

		```haxe
		if (e.match(pattern)) {
			// codeIfTrue
		} else {
			// codeIfFalse
		}
		```

		This is equivalent to the following code:

		```haxe
		switch (e) {
			case pattern:
				// codeIfTrue
			case _:
				// codeIfFalse
		}
		```

		This method is implemented in the compiler. This definition exists only
		for documentation.</haxe_doc>
		</match>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an 
  [extension](https://haxe.org/manual/lf-static-extension.html) to the 
  `EnumValue` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<abstract path="haxe.Int32" params="" file="/home/travis/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
 	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/home/travis/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="/home/travis/haxe/std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/home/travis/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta>
		<m n=":keep"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="/home/travis/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>* This typedef will fool @:coreApi into thinking that we are using
  * the same underlying type, even though it might be different on
  * specific platforms.</haxe_doc>
	</typedef>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/home/travis/haxe/std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/home/travis/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="/home/travis/haxe/std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</to>
		<haxe_doc><![CDATA[An abstract type allowing values to be either of `T1` or `T2` type.
	Supports implicit casts from/to either types.

	It is useful for interfacing with external code on dynamic platforms
	such as JavaScript or Python.

	Otherwise, use of this type is discouraged.
	
	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="/home/travis/haxe/std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.extern.Rest" params="T" file="/home/travis/haxe/std/haxe/extern/Rest.hx">
		<this><c path="Array"><c path="haxe.extern.Rest.T"/></c></this>
		<haxe_doc><![CDATA[A special abstract type that represents "rest" function argument.

	Should be used as a type for the last argument of an extern method,
	representing that arbitrary number of arguments of given type can be
	passed to that method.
	
	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<impl><class path="haxe.extern._Rest.Rest_Impl_" params="" file="/home/travis/haxe/std/haxe/extern/Rest.hx" private="1" module="haxe.extern.Rest"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<typedef path="haxe.io.BytesData" params="" file="/home/travis/haxe/std/haxe/io/BytesData.hx"><c path="Array"><x path="Int"/></c></typedef>
	<class path="haxe.io.Eof" params="" file="/home/travis/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.macro.IncludePosition" params="" file="/home/travis/haxe/std/haxe/macro/Compiler.hx" module="haxe.macro.Compiler">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.macro._Compiler.IncludePosition_Impl_" params="" file="/home/travis/haxe/std/haxe/macro/Compiler.hx" private="1" module="haxe.macro.Compiler"><meta>
	<m n=":keep"/>
	<m n=":final"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<typedef path="haxe.macro.Position" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<min>
				<x path="Int"/>
				<haxe_doc>Position of the first character.</haxe_doc>
			</min>
			<max>
				<x path="Int"/>
				<haxe_doc>Position of the last character.</haxe_doc>
			</max>
			<file>
				<c path="String"/>
				<haxe_doc>Reference to the filename.</haxe_doc>
			</file>
		</a>
		<haxe_doc>Represents a position in a file.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Expr" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.ExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a node in the AST.
	@see https://haxe.org/manual/macro-reification-expression.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<t path="haxe.macro.Expr"/>
		<haxe_doc>Represents a AST node identical to `Expr`, but it allows constraining the
	type of accepted expressions.
	@see https://haxe.org/manual/macro-ExprOf.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Case" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<values>
				<c path="Array"><t path="haxe.macro.Expr"/></c>
				<haxe_doc>The value expressions of the case.</haxe_doc>
			</values>
			<guard>
				<t path="Null"><t path="Null"><t path="haxe.macro.Expr"/></t></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional guard expressions of the case, if available.</haxe_doc>
			</guard>
			<expr>
				<t path="Null"><t path="haxe.macro.Expr"/></t>
				<haxe_doc>The expression of the case, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a switch case.
	@see https://haxe.org/manual/expression-switch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Var" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<t path="Null"><e path="haxe.macro.ComplexType"/></t>
				<haxe_doc>The type-hint of the variable, if available.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<expr>
				<t path="Null"><t path="haxe.macro.Expr"/></t>
				<haxe_doc>The expression of the variable, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a variable in the AST.
	@see https://haxe.org/manual/expression-var.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Catch" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<e path="haxe.macro.ComplexType"/>
				<haxe_doc>The type of the catch.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the catch variable.</haxe_doc>
			</name>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The expression of the catch.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a catch in the AST.
	@https://haxe.org/manual/expression-try-catch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypePath" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<sub>
				<t path="Null"><t path="Null"><c path="String"/></t></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sub is set on module sub-type access:
		`pack.Module.Type` has name = Module, sub = Type, if available.</haxe_doc>
			</sub>
			<params>
				<t path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional parameters of the type path.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>Represents the package of the type path.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type path.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a type path in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<params>
				<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the type parameter.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<meta>
				<t path="Null"><t path="haxe.macro.Metadata"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the type parameter.</haxe_doc>
			</meta>
			<constraints>
				<t path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional constraints of the type parameter.</haxe_doc>
			</constraints>
		</a>
		<haxe_doc>Represents a type parameter declaration in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Function" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<ret>
				<t path="Null"><e path="haxe.macro.ComplexType"/></t>
				<haxe_doc>The return type-hint of the function, if available.</haxe_doc>
			</ret>
			<params>
				<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional list of function parameter type declarations.</haxe_doc>
			</params>
			<expr>
				<t path="Null"><t path="haxe.macro.Expr"/></t>
				<haxe_doc>The expression of the function body, if available.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><t path="haxe.macro.FunctionArg"/></c>
				<haxe_doc>A list of function arguments.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<value>
				<t path="Null"><t path="Null"><t path="haxe.macro.Expr"/></t></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional value of the function argument, if available.</haxe_doc>
			</value>
			<type>
				<t path="Null"><e path="haxe.macro.ComplexType"/></t>
				<haxe_doc>The type-hint of the function argument, if available.</haxe_doc>
			</type>
			<opt>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the function argument is optional.</haxe_doc>
			</opt>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the function argument.</haxe_doc>
			</name>
			<meta>
				<t path="Null"><t path="haxe.macro.Metadata"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the function argument.</haxe_doc>
			</meta>
		</a>
		<haxe_doc>Represents a function argument in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the metadata entry.</haxe_doc>
			</pos>
			<params>
				<t path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the metadata entry.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the metadata entry.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a metadata entry in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
		<haxe_doc>Represents metadata in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Field" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the field.</haxe_doc>
			</pos>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<t path="Null"><t path="haxe.macro.Metadata"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldType"/>
				<haxe_doc>The kind of the field.</haxe_doc>
			</kind>
			<doc>
				<t path="Null"><t path="Null"><c path="String"/></t></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the field, if available. If the field has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
			<access>
				<t path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The access modifiers of the field. By default fields have private access.
		@see https://haxe.org/manual/class-field-access-modifier.html</haxe_doc>
			</access>
		</a>
		<haxe_doc>Represents a field in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position to the type definition.</haxe_doc>
			</pos>
			<params>
				<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The paramater type declarations of the type definition.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type definition.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type definition.</haxe_doc>
			</name>
			<meta>
				<t path="Null"><t path="haxe.macro.Metadata"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the type definition.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.TypeDefKind"/>
				<haxe_doc>The kind of the type definition.</haxe_doc>
			</kind>
			<isExtern>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<fields>
				<c path="Array"><t path="haxe.macro.Field"/></c>
				<haxe_doc>The fields of the type definition.</haxe_doc>
			</fields>
		</a>
		<haxe_doc>Represents a type definition.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<path>
				<c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c>
				<haxe_doc>The path to the import expression.</haxe_doc>
			</path>
			<mode>
				<e path="haxe.macro.ImportMode"/>
				<haxe_doc>The mode of the import expression.</haxe_doc>
			</mode>
		</a>
		<haxe_doc>Represents the import expression.</haxe_doc>
	</typedef>
	<class path="lua.NativeStringTools" params="" file="/home/travis/haxe/std/lua/NativeStringTools.hx" extern="1">
		<len public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Receives a string and returns its length. The empty string `""` has 
		length `0`. Embedded zeros are counted, so `"a\000bc\000"` has length `5`.</haxe_doc>
		</len>
		<char public="1" set="method" static="1">
			<f a="codes">
				<x path="haxe.extern.Rest"><x path="Int"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Receives zero or more integers. Returns a string with length equal to the 
		number of arguments, in which each character has the internal numerical 
		code equal to its corresponding argument.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</char>
		<sub public="1" set="method" static="1">
			<f a="str:start:?end">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.StringSub"/>
			</f>
			<haxe_doc>Returns the substring of `str` that starts at `start` and continues until `end`; 
		`start` and `end` can be negative. If `end` is absent, then it is assumed to be 
		equal to `-1` (which is the same as the string length). 
		In particular, the call `sub(str,1,end)` returns a prefix of `str` 
		with length `end`, and `sub(str, -end)` returns a suffix of `str` with 
		length `start`.</haxe_doc>
		</sub>
		<charCodeAt public="1" set="method" static="1">
			<f a="str:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the character code at position `index` of `str`.</haxe_doc>
		</charCodeAt>
		<find public="1" set="method" static="1">
			<f a="str:target:?start:?plain">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="lua.StringFind"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string `str`. 
		If it finds a match, then `find` returns the indices of `str` where this 
		occurrence starts and ends.
		
		@param target If the target has captures, then in a successful match the 
		       captured values are also returned, after the two indices.
		@param start specifies where to start the search; its default value is `1`
		       and can be negative. 
		@param plain turns off the pattern matching facilities, so the function does 
		       a plain "find substring" operation, with no characters in pattern 
		       being considered "magic". Note that if plain is given, then `start` must be given as well.</haxe_doc>
		</find>
		<byte public="1" set="method" static="1">
			<f a="str:?index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the internal numerical codes of the characters `str[index]`.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</byte>
		<format public="1" set="method" static="1">
			<f a="str:?e1:?e2:?e3:?e4">
				<c path="String"/>
				<d/>
				<d/>
				<d/>
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a formatted version of its variable number of arguments following 
		the description given in its first argument (which must be a string). 
		The format string follows the same rules as the printf family of standard C 
		functions. The only differences are that the options/modifiers 
		`*`, `l`, `L`, `n`, `p`, and `h` are not supported and that there is an 
		extra option, `q`. The `q` option formats a string in a form suitable to be
		safely read back by the Lua interpreter: the string is written between 
		double quotes, and all double quotes, newlines, embedded zeros, 
		and backslashes in the string are correctly escaped when written.
		For instance, the call
   `string.format('%q', 'a string with "quotes" and \n new line')`
		will produce the string:
		`"a string with \"quotes\" and \
      new line"`
		
		The options `c`, `d` `E`, `e`, `f`, `g`, `G`, `i`, `o`, `u, `X-, and `x` all 
		expect a number as argument, whereas `q` and `s` expect a string.
		
		This function does not accept string values containing embedded zeros, 
		except as arguments to the `q` option.</haxe_doc>
		</format>
		<gsub public="1" set="method" static="1">
			<f a="str:pattern:replace:?n">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
			<overloads>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<x path="Void"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<c path="String"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
			</overloads>
		</gsub>
		<gmatch public="1" set="method" static="1">
			<f a="str:pattern">
				<c path="String"/>
				<c path="String"/>
				<f a=""><c path="String"/></f>
			</f>
			<haxe_doc>Returns an iterator function that, each time it is called, returns the next 
		captures from pattern over string `str`. If `pattern` specifies no captures, 
		then the whole match is produced in each call.</haxe_doc>
			<overloads><gmatch public="1" set="method">
	<f a="str:pattern:match:?n">
		<c path="String"/>
		<c path="String"/>
		<f a=""><c path="String"/></f>
		<x path="Int"/>
		<f a="">
			<c path="String"/>
			<x path="Void"/>
		</f>
	</f>
	<haxe_doc>Returns an iterator function that, each time it is called, returns the next 
		captures from pattern over string `str`. If `pattern` specifies no captures, 
		then the whole match is produced in each call.</haxe_doc>
</gmatch></overloads>
		</gmatch>
		<match public="1" set="method" static="1">
			<f a="str:pattern:?n">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string s. If it finds one, 
		then match returns the captures from the pattern; otherwise it returns `null`.
		If pattern specifies no captures, then the whole match is returned.
		The optional argument `n` specifies where to start the search; 
		its default value is `1` and can be negative.</haxe_doc>
		</match>
		<upper public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all lowercase 
		letters changed to uppercase. All other characters are left unchanged. 
		The definition of what a lowercase letter is depends on the current locale.</haxe_doc>
		</upper>
		<lower public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all uppercase 
		letters changed to lowercase. All other characters are left unchanged. 
		The definition of what an uppercase letter is depends on the current locale.</haxe_doc>
		</lower>
		<dump public="1" set="method" static="1">
			<f a="d">
				<d/>
				<d/>
			</f>
			<haxe_doc>Returns a string containing a binary representation of the given function,
		so that a later loadstring on this string returns a copy of the function.
		function must be a Lua function without upvalues.</haxe_doc>
		</dump>
		<haxe_doc>These are all externs for the base Lua "string" class, which functions 
	as an additional set of string tools.

	Note that all relevant indexes are "1" based.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G.string"</e></m>
		</meta>
	</class>
	<class path="lua.Boot" params="" file="/home/travis/haxe/std/lua/Boot.hx">
		<hiddenFields expr="untyped __lua__(&quot;{__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}&quot;)" line="37" static="1">
			<c path="lua.Table">
				<c path="String"/>
				<x path="Bool"/>
			</c>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>untyped __lua__("{__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}")</e></m>
			</meta>
		</hiddenFields>
		<isArray set="method" line="113" static="1">
			<f a="o">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isArray>
		<printEnum set="method" line="140" static="1"><f a="o:s">
	<c path="Array"><d/></c>
	<c path="String"/>
	<c path="String"/>
</f></printEnum>
		<printClassRec set="method" line="167" static="1">
			<f a="c:?result:s" v=":&quot;&quot;:">
				<c path="lua.Table">
					<c path="String"/>
					<d/>
				</c>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ result : "" }</e></m>
			</meta>
		</printClassRec>
		<__string_rec set="method" line="177" static="1">
			<f a="o:?s" v=":&quot;&quot;">
				<d/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ s : "" }</e></m>
				<m n=":ifFeature"><e>"has_enum"</e></m>
			</meta>
		</__string_rec>
		<fieldIterator public="1" set="method" line="352" static="1">
			<f a="o">
				<c path="lua.Table">
					<c path="String"/>
					<d/>
				</c>
				<t path="Iterator"><c path="String"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fieldIterator>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="lua.FileHandle" params="" file="/home/travis/haxe/std/lua/FileHandle.hx" extern="1">
		<extends path="lua.UserData"/>
		<flush public="1" set="method"><f a=""><x path="Void"/></f></flush>
		<read public="1" set="method"><f a="arg">
	<x path="haxe.extern.Rest"><x path="haxe.extern.EitherType">
	<x path="lua.ReadArgument"/>
	<x path="Int"/>
</x></x>
	<c path="String"/>
</f></read>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<write public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<seek public="1" set="method">
			<f a="arg:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads><seek public="1" set="method"><f a=""><x path="Int"/></f></seek></overloads>
		</seek>
	</class>
	<abstract path="lua.ReadArgument" params="" file="/home/travis/haxe/std/lua/FileHandle.hx" module="lua.FileHandle">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._FileHandle.ReadArgument_Impl_" params="" file="/home/travis/haxe/std/lua/FileHandle.hx" private="1" module="lua.FileHandle"><meta>
	<m n=":keep"/>
	<m n=":final"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.Io" params="" file="/home/travis/haxe/std/lua/Io.hx" extern="1">
		<stdin public="1" static="1"><c path="lua.FileHandle"/></stdin>
		<stderr public="1" static="1"><c path="lua.FileHandle"/></stderr>
		<stdout public="1" static="1"><c path="lua.FileHandle"/></stdout>
		<close public="1" set="method" static="1">
			<f a="?file">
				<c path="lua.FileHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Function to close regular files.</haxe_doc>
		</close>
		<flush public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Saves any written data to file.</haxe_doc>
		</flush>
		<input public="1" set="method" static="1">
			<f a="file">
				<c path="lua.FileHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>When called with a file name, it opens the named file (in text mode),
		and sets its handle as the default input file. When called with a file handle,
		it simply sets this file handle as the default input file.
		When called without parameters, it returns the current default input file.

		In case of errors this function raises the error, instead of returning an
		error code.</haxe_doc>
			<overloads><input public="1" set="method">
	<f a="file">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>When called with a file name, it opens the named file (in text mode),
		and sets its handle as the default input file. When called with a file handle,
		it simply sets this file handle as the default input file.
		When called without parameters, it returns the current default input file.

		In case of errors this function raises the error, instead of returning an
		error code.</haxe_doc>
</input></overloads>
		</input>
		<lines public="1" set="method" static="1">
			<f a="?file">
				<c path="String"/>
				<x path="lua.NativeIterator"><c path="String"/></x>
			</f>
			<haxe_doc>Opens the given file name in read mode and returns an iterator function that, 
		each time it is called, returns a new line from the file.</haxe_doc>
		</lines>
		<open public="1" set="method" static="1">
			<f a="filename:?mode">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.FileHandle"/>
			</f>
			<haxe_doc>This function opens a file, in the mode specified in the string mode.
		It returns a new file handle, or, in case of errors, `null` plus an error message.
		
		The mode string can be any of the following:
		
		 * `"r"`: read mode (the default)
		 * `"w"`: write mode
		 * `"a"`: append mode
		 * `"r+"`: update mode, all previous data is preserved
		 * `"w+"`: update mode, all previous data is erased
		 * `"a+"`: append update mode, previous data is preserved, writing is only 
		    allowed at the end of file
		
		The mode string can also have a `b` at the end, which is needed in some systems 
		to open the file in binary mode. This string is exactly what is used in the 
		standard C function fopen.</haxe_doc>
		</open>
		<popen public="1" set="method" static="1">
			<f a="command:?mode">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.FileHandle"/>
			</f>
			<haxe_doc>Starts program `command` in a separated process and returns a file handle that 
		you can use to read data from this program (if mode is `"r"`, the default) 
		or to write data to this program (if mode is `"w"`).
		
		This function is system dependent and is not available on all platforms.</haxe_doc>
		</popen>
		<read public="1" set="method" static="1">
			<f a="?filename">
				<c path="String"/>
				<c path="String"/>
			</f>
			<overloads><read public="1" set="method"><f a="?count">
	<x path="Int"/>
	<c path="String"/>
</f></read></overloads>
		</read>
		<write public="1" set="method" static="1">
			<f a="v">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes the value of each of its arguments to the file. The arguments must 
		be strings or numbers. 
		To write other values, use `Lua.tostring` or `NativeStringTools.format`
		before write.</haxe_doc>
		</write>
		<output public="1" set="method" static="1"><f a="?file">
	<c path="String"/>
	<c path="lua.FileHandle"/>
</f></output>
		<tmpfile public="1" set="method" static="1">
			<f a=""><c path="lua.FileHandle"/></f>
			<haxe_doc>Returns a handle for a temporary file. This file is opened in update mode
		and it is automatically removed when the program ends.</haxe_doc>
		</tmpfile>
		<type public="1" set="method" static="1">
			<f a="obj">
				<c path="lua.FileHandle"/>
				<x path="lua.IoType"/>
			</f>
			<haxe_doc>Checks whether `obj` is a valid file handle.</haxe_doc>
		</type>
		<haxe_doc>Input and Output Facilities</haxe_doc>
		<meta><m n=":native"><e>"_G.io"</e></m></meta>
	</class>
	<abstract path="lua.IoType" params="" file="/home/travis/haxe/std/lua/Io.hx" module="lua.Io">
		<this><c path="String"/></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<haxe_doc>A enumerator that describes the output of `Io.type()`.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._Io.IoType_Impl_" params="" file="/home/travis/haxe/std/lua/Io.hx" private="1" module="lua.Io"><meta>
	<m n=":keep"/>
	<m n=":final"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="lua.LocaleCategory" params="" file="/home/travis/haxe/std/lua/LocaleCategory.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._LocaleCategory.LocaleCategory_Impl_" params="" file="/home/travis/haxe/std/lua/LocaleCategory.hx" private="1" module="lua.LocaleCategory"><meta>
	<m n=":keep"/>
	<m n=":final"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.Lua" params="" file="/home/travis/haxe/std/lua/Lua.hx" extern="1">
		<_VERSION public="1" static="1">
			<c path="String"/>
			<haxe_doc>A global variable that holds a string containing the current interpreter
		version.</haxe_doc>
		</_VERSION>
		<arg public="1" static="1"><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></arg>
		<getmetatable public="1" set="method" static="1">
			<f a="tbl">
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
			</f>
			<haxe_doc>Pushes onto the stack the metatable in the registry.</haxe_doc>
		</getmetatable>
		<setmetatable public="1" set="method" static="1">
			<f a="tbl:mtbl">
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<x path="Void"/>
			</f>
			<haxe_doc>Pops a table from the stack and sets it as the new metatable for the value
		at the given acceptable index.</haxe_doc>
		</setmetatable>
		<setfenv public="1" set="method" static="1">
			<f a="i:tbl">
				<x path="Int"/>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<x path="Void"/>
			</f>
			<haxe_doc>Pops a table from the stack and sets it as the new environment for the value
		at the given index. If the value at the given index is neither a function nor
		a thread nor a userdata, lua_setfenv returns `0`.
		Otherwise it returns `1`.</haxe_doc>
		</setfenv>
		<next public="1" params="K:V" set="method" static="1">
			<f a="k:?i">
				<c path="lua.Table">
					<c path="next.K"/>
					<c path="next.V"/>
				</c>
				<c path="next.V"/>
				<c path="lua.NextResult">
					<c path="next.K"/>
					<c path="next.V"/>
				</c>
			</f>
			<haxe_doc>Allows a program to traverse all fields of a table.
		Its first argument is a table and its second argument is an index in this
		table. `next` returns the next index of the table and its associated value.
		When `i` is `null`, `next` returns an initial index and its associated value.
		When called with the last index, or with `null` in an empty table, `next`
		returns `null`.  In particular, you can use `next(t)` to check whether a
		table is empty.

		The order in which the indices are enumerated is not specified, even for
		numeric indices. (To traverse a table in numeric order, use a numerical for
		or the `ipairs` function).

		The behavior of next is undefined if, during the traversal, any value
		to a non-existent field in the table is assigned. Existing fields may
		however be modified. In particular, existing fields may be cleared.</haxe_doc>
		</next>
		<tostring public="1" set="method" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives an argument of any type and converts it to a string in a reasonable
		format.

		For complete control of how numbers are converted, use`NativeStringTools.format`.</haxe_doc>
		</tostring>
		<ipairs public="1" params="T" set="method" static="1"><f a="t">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="ipairs.T"/>
	</c>
	<c path="lua.PairsResult">
		<x path="Int"/>
		<c path="ipairs.T"/>
	</c>
</f></ipairs>
		<pairs public="1" params="K:V" set="method" static="1"><f a="t">
	<c path="lua.Table">
		<c path="pairs.K"/>
		<c path="pairs.V"/>
	</c>
	<c path="lua.PairsResult">
		<c path="pairs.K"/>
		<c path="pairs.V"/>
	</c>
</f></pairs>
		<require public="1" set="method" static="1"><f a="module">
	<c path="String"/>
	<d/>
</f></require>
		<tonumber public="1" set="method" static="1">
			<f a="str:?base">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts the Lua value at the given acceptable base to `Int`.
		The Lua value must be a number or a string convertible to a number,
		otherwise `tonumber` returns `0`.</haxe_doc>
		</tonumber>
		<type public="1" set="method" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the Lua type of its only argument as a string.
		The possible results of this function are:

		 * `"nil"` (a string, not the Lua value nil),
		 * `"number"`
		 * `"string"`
		 * `"boolean"`
		 * `"table"`
		 * `"function"`
		 * `"thread"`
		 * `"userdata"`</haxe_doc>
		</type>
		<print public="1" set="method" static="1">
			<f a="v">
				<x path="haxe.extern.Rest"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Receives any number of arguments, and prints their values to stdout,
		using the tostring function to convert them to strings.
		`print` is not intended for formatted output, but only as a quick way to show
		a value, typically for debugging.

		For complete control of how numbers are converted, use `NativeStringTools.format`.</haxe_doc>
		</print>
		<select public="1" set="method" static="1">
			<f a="n:rest">
				<d/>
				<x path="haxe.extern.Rest"><d/></x>
				<d/>
			</f>
			<haxe_doc>If `n` is a number, returns all arguments after argument number `n`.
		Otherwise, `n` must be the string `"#"`, and select returns the total
		number of extra arguments it received.</haxe_doc>
		</select>
		<rawget public="1" params="K:V" set="method" static="1">
			<f a="t:k">
				<c path="lua.Table">
					<c path="rawget.K"/>
					<c path="rawget.V"/>
				</c>
				<c path="rawget.K"/>
				<c path="rawget.V"/>
			</f>
			<haxe_doc>Gets the real value of `table[index]`, without invoking any metamethod.</haxe_doc>
		</rawget>
		<rawset public="1" params="K:V" set="method" static="1">
			<f a="t:k:v">
				<c path="lua.Table">
					<c path="rawset.K"/>
					<c path="rawset.V"/>
				</c>
				<c path="rawset.K"/>
				<c path="rawset.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the real value of `table[index]` to value, without invoking any metamethod.</haxe_doc>
		</rawset>
		<collectgarbage public="1" set="method" static="1">
			<f a="opt:?arg">
				<x path="lua.CollectGarbageOption"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>This function is a generic interface to the garbage collector.
		It performs different functions according to its first argument.</haxe_doc>
		</collectgarbage>
		<assert public="1" params="T" set="method" static="1">
			<f a="v:?message">
				<c path="assert.T"/>
				<c path="String"/>
				<c path="assert.T"/>
			</f>
			<haxe_doc>Issues an error when the value of its argument `v` is `false` (i.e., `null`
		or `false`) otherwise, returns all its arguments. message is an error message.
		when absent, it defaults to "assertion failed!"</haxe_doc>
		</assert>
		<dofile public="1" set="method" static="1">
			<f a="filename">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Loads and runs the given file.</haxe_doc>
		</dofile>
		<error public="1" set="method" static="1">
			<f a="message:?level">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Generates a Lua error. The error message (which can actually be a Lua value
		of any type) must be on the stack top. This function does a long jump,
		and therefore never returns.</haxe_doc>
		</error>
		<pcall public="1" set="method" static="1">
			<f a="f:rest">
				<x path="haxe.Function"/>
				<x path="haxe.extern.Rest"><d/></x>
				<c path="lua.PCallResult"/>
			</f>
			<haxe_doc>Calls a function in protected mode.</haxe_doc>
		</pcall>
		<rawequal public="1" set="method" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the two values in acceptable indices `v1` and `v2` are
		primitively equal (that is, without calling metamethods).
		Otherwise returns `false`.
		Also returns `false` if any of the indices are non valid.</haxe_doc>
		</rawequal>
		<xpcall public="1" set="method" static="1">
			<f a="f:msgh:rest">
				<x path="haxe.Function"/>
				<x path="haxe.Function"/>
				<x path="haxe.extern.Rest"><d/></x>
				<c path="lua.PCallResult"/>
			</f>
			<haxe_doc>This function is similar to pcall, except that you can set a new error
		handler.</haxe_doc>
		</xpcall>
		<loadfile public="1" set="method" static="1">
			<f a="filename">
				<c path="String"/>
				<c path="lua.LoadResult"/>
			</f>
			<haxe_doc>Loads the chunk from file filename or from the standard input if no filename
		is given.</haxe_doc>
		</loadfile>
		<load public="1" set="method" static="1">
			<f a="code">
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<f a=""><c path="String"/></f>
				</x>
				<c path="lua.LoadResult"/>
			</f>
			<haxe_doc>Loads the chunk from given string.</haxe_doc>
		</load>
		<haxe_doc>These are all global static methods within Lua.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<abstract path="lua.CollectGarbageOption" params="" file="/home/travis/haxe/std/lua/Lua.hx" module="lua.Lua">
		<this><c path="String"/></this>
		<haxe_doc>Enum for describing garbage collection options</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._Lua.CollectGarbageOption_Impl_" params="" file="/home/travis/haxe/std/lua/Lua.hx" private="1" module="lua.Lua"><meta>
	<m n=":keep"/>
	<m n=":final"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.PCallResult" params="" file="/home/travis/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<status public="1"><x path="Bool"/></status>
		<error public="1"><c path="String"/></error>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.NextResult" params="K:V" file="/home/travis/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<index public="1"><c path="lua.NextResult.K"/></index>
		<value public="1"><c path="lua.NextResult.V"/></value>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.PairsResult" params="K:V" file="/home/travis/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<next public="1"><f a=":">
	<c path="lua.Table">
		<c path="lua.PairsResult.K"/>
		<c path="lua.PairsResult.V"/>
	</c>
	<c path="lua.PairsResult.K"/>
	<c path="lua.NextResult">
		<c path="lua.PairsResult.K"/>
		<c path="lua.PairsResult.V"/>
	</c>
</f></next>
		<table public="1"><c path="lua.Table">
	<c path="lua.PairsResult.K"/>
	<c path="lua.PairsResult.V"/>
</c></table>
		<index public="1"><c path="lua.PairsResult.V"/></index>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.LoadResult" params="" file="/home/travis/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<func public="1"><x path="haxe.Function"/></func>
		<message public="1"><c path="String"/></message>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.Math" params="" file="/home/travis/haxe/std/lua/Math.hx" extern="1">
		<pi public="1" static="1"><x path="Float"/></pi>
		<huge public="1" static="1"><x path="Float"/></huge>
		<NaN public="1" static="1"><x path="Float"/></NaN>
		<abs public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></abs>
		<ceil public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Int"/>
</f></ceil>
		<floor public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Int"/>
</f></floor>
		<acos public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<asin public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<atan public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<atan2 public="1" set="method" static="1"><f a="i:j">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<cos public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></cos>
		<cosh public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></cosh>
		<sin public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></sin>
		<sinh public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></sinh>
		<tan public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<tanh public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></tanh>
		<rad public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></rad>
		<modf public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></modf>
		<fmod public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></fmod>
		<pow public="1" set="method" static="1"><f a="i:j">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<sqrt public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<exp public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></exp>
		<frexp public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></frexp>
		<ldexp public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></ldexp>
		<log public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></log>
		<log10 public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></log10>
		<max public="1" set="method" static="1"><f a="i:j">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></max>
		<min public="1" set="method" static="1"><f a="i:j">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></min>
		<random public="1" set="method" static="1"><f a=""><x path="Float"/></f></random>
		<randomseed public="1" set="method" static="1"><f a="i">
	<x path="Float"/>
	<x path="Float"/>
</f></randomseed>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G.math"</e></m>
		</meta>
	</class>
	<abstract path="lua.NativeIterator" params="T" file="/home/travis/haxe/std/lua/NativeIterator.hx">
		<from><icast field="fromF"><f a=""><c path="fromF.T"/></f></icast></from>
		<this><f a=""><c path="lua.NativeIterator.T"/></f></this>
		<to><icast field="toIterator"><a>
	<next set="method">
		<f a=""><c path="lua.NativeIterator.T"/></f>
		<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
	</next>
	<hasNext set="method">
		<f a=""><x path="Bool"/></f>
		<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
	</hasNext>
</a></icast></to>
		<haxe_doc>This abstract enables easy conversion from basic lua iterators
	(i.e., a function that is called until it returns null), and 
	Haxe iterators, which provide a next/hasNext interface.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="lua._NativeIterator.NativeIterator_Impl_" params="" file="/home/travis/haxe/std/lua/NativeIterator.hx" private="1" module="lua.NativeIterator"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="lua.StringFind" params="" file="/home/travis/haxe/std/lua/NativeStringTools.hx" module="lua.NativeStringTools" extern="1">
		<begin public="1"><x path="Int"/></begin>
		<end public="1"><x path="Int"/></end>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.StringSub" params="" file="/home/travis/haxe/std/lua/NativeStringTools.hx" module="lua.NativeStringTools" extern="1">
		<match public="1"><c path="String"/></match>
		<count public="1"><x path="Int"/></count>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.Os" params="" file="/home/travis/haxe/std/lua/Os.hx" extern="1">
		<clock public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns an approximation of the amount in seconds of CPU time used by the
		program.</haxe_doc>
		</clock>
		<date public="1" set="method" static="1">
			<f a=""><t path="lua.DateType"/></f>
			<overloads>
				<date public="1" set="method"><f a="format:time">
	<c path="String"/>
	<t path="lua.Time"/>
	<t path="lua.DateType"/>
</f></date>
				<date public="1" set="method"><f a="format">
	<c path="String"/>
	<t path="lua.DateType"/>
</f></date>
			</overloads>
		</date>
		<difftime public="1" set="method" static="1">
			<f a="t2:t1">
				<t path="lua.Time"/>
				<t path="lua.Time"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the number of seconds from time `t1` to time `t2`. 
		In POSIX, Windows, and some other systems, this value is exactly `t2-t1`.</haxe_doc>
		</difftime>
		<execute public="1" set="method" static="1">
			<f a="?command">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>This function is equivalent to the C function system. It passes command to 
		be executed by an operating system shell. It returns a status code,
		which is system-dependent. If command is absent, then it returns 
		nonzero if a shell is available and zero otherwise.</haxe_doc>
		</execute>
		<exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Calls the C function exit, with an optional code, to terminate the host program. 
		The default value for code is the success code.</haxe_doc>
		</exit>
		<getenv public="1" set="method" static="1">
			<f a="varname">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the process environment variable `varname`, or `null` 
		if the variable is not defined.</haxe_doc>
		</getenv>
		<remove public="1" set="method" static="1">
			<f a="filename">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the file or directory with the given name.
		Directories must be empty to be removed.</haxe_doc>
		</remove>
		<rename public="1" set="method" static="1">
			<f a="oldname:newname">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Renames file or directory named `oldname` to `newname`.</haxe_doc>
		</rename>
		<setlocale public="1" set="method" static="1">
			<f a="locale:?category">
				<c path="String"/>
				<x path="lua.LocaleCategory"/>
				<c path="String"/>
			</f>
			<haxe_doc>Sets the current locale of the program.</haxe_doc>
		</setlocale>
		<time public="1" set="method" static="1">
			<f a="?arg">
				<t path="lua.TimeParam"/>
				<t path="lua.Time"/>
			</f>
			<haxe_doc>Returns the current time when called without arguments, or a time 
		representing the date and time specified by the given table. 

		The returned value is a number, whose meaning depends on your system. 
		In POSIX, Windows, and some other systems, this number counts the number 
		of seconds since some given start time (the "epoch"). 
		In other systems, the meaning is not specified, and the number returned
		by time can be used only as an argument to date and difftime.</haxe_doc>
		</time>
		<tmpname public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string with a file name that can be used for a temporary file. 
		The file must be explicitly opened before its use and explicitly removed
		when no longer needed.
		
		When possible, you may prefer to use `Io.tmpfile`, which automatically 
		removes the file when the program ends.</haxe_doc>
		</tmpname>
		<haxe_doc>Operating System Facilities.</haxe_doc>
		<meta><m n=":native"><e>"_G.os"</e></m></meta>
	</class>
	<typedef path="lua.TimeParam" params="" file="/home/travis/haxe/std/lua/Os.hx" module="lua.Os">
		<a>
			<year><x path="Float"/></year>
			<sec>
				<t path="Null"><x path="Int"/></t>
				<meta><m n=":optional"/></meta>
			</sec>
			<month><x path="Float"/></month>
			<min>
				<t path="Null"><x path="Int"/></t>
				<meta><m n=":optional"/></meta>
			</min>
			<isdst>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
			</isdst>
			<hour>
				<t path="Null"><x path="Int"/></t>
				<meta><m n=":optional"/></meta>
			</hour>
			<day><x path="Float"/></day>
		</a>
		<haxe_doc>A typedef that matches the date parameter `Os.time()` will accept.</haxe_doc>
	</typedef>
	<typedef path="lua.DateType" params="" file="/home/travis/haxe/std/lua/Os.hx" module="lua.Os">
		<a>
			<year><x path="Int"/></year>
			<yday><x path="Int"/></yday>
			<wday><x path="Int"/></wday>
			<sec><x path="Int"/></sec>
			<month><x path="Int"/></month>
			<min><x path="Int"/></min>
			<isdst><x path="Bool"/></isdst>
			<hour><x path="Int"/></hour>
			<day><x path="Int"/></day>
		</a>
		<haxe_doc>A typedef that describes the output of `Os.date()`.</haxe_doc>
	</typedef>
	<class path="lua.OsExecute" params="" file="/home/travis/haxe/std/lua/Os.hx" module="lua.Os" extern="1">
		<success public="1"><x path="Bool"/></success>
		<output public="1"><c path="String"/></output>
		<status public="1"><x path="Int"/></status>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.Package" params="" file="/home/travis/haxe/std/lua/Package.hx" extern="1">
		<config public="1" static="1">
			<c path="String"/>
			<haxe_doc>A string describing some compile-time configurations for packages.</haxe_doc>
		</config>
		<path public="1" static="1">
			<c path="String"/>
			<haxe_doc>The path used by require to search for a Lua loader.</haxe_doc>
		</path>
		<cpath public="1" static="1">
			<c path="String"/>
			<haxe_doc>The path used by require to search for a C loader.</haxe_doc>
		</cpath>
		<loaded public="1" static="1">
			<c path="lua.Table">
				<c path="String"/>
				<x path="Bool"/>
			</c>
			<haxe_doc>A table used by require to control which modules are already loaded.</haxe_doc>
		</loaded>
		<preload public="1" static="1">
			<c path="lua.Table">
				<c path="String"/>
				<x path="Bool"/>
			</c>
			<haxe_doc>A table to store loaders for specific modules.</haxe_doc>
		</preload>
		<searchers public="1" static="1">
			<c path="lua.Table">
				<x path="Int"/>
				<f a=""><t path="Null"><c path="String"/></t></f>
			</c>
			<haxe_doc>A table used by require to control how to load modules.
		Each entry in this table is a searcher function.</haxe_doc>
		</searchers>
		<searchpath public="1" set="method" static="1">
			<f a="name:path:?sep:?rep">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<t path="Null"><c path="String"/></t>
			</f>
			<haxe_doc>Searches for the given `libname` in the given path `funcname`.
		A path is a string containing a sequence of templates separated by semicolons.</haxe_doc>
		</searchpath>
		<loadlib public="1" set="method" static="1">
			<f a="libname:funcname">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Dynamically links the host program with the C library `libname`.</haxe_doc>
		</loadlib>
		<haxe_doc>Externs for lua package handling</haxe_doc>
		<meta><m n=":native"><e>"_G.package"</e></m></meta>
	</class>
	<class path="lua.Table" params="A:B" file="/home/travis/haxe/std/lua/Table.hx" extern="1">
		<create public="1" params="A:B" get="inline" set="null" line="8" static="1">
			<f a="?arr:?hsh">
				<c path="Array"><c path="create.B"/></c>
				<d><c path="create.B"/></d>
				<c path="lua.Table">
					<c path="create.A"/>
					<c path="create.B"/>
				</c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<concat public="1" params="A:B" set="method" static="1">
			<f a="table:?sep">
				<c path="lua.Table">
					<c path="concat.A"/>
					<c path="concat.B"/>
				</c>
				<c path="String"/>
				<c path="String"/>
			</f>
			<overloads><concat public="1" params="A:B" set="method"><f a="table">
	<c path="lua.Table">
		<c path="concat.A"/>
		<c path="concat.B"/>
	</c>
	<x path="Void"/>
</f></concat></overloads>
		</concat>
		<foreach public="1" params="A:B" set="method" static="1"><f a="table:f">
	<c path="lua.Table">
		<c path="foreach.A"/>
		<c path="foreach.B"/>
	</c>
	<f a=":">
		<c path="foreach.A"/>
		<c path="foreach.B"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></foreach>
		<foreachi public="1" params="A:B" set="method" static="1"><f a="table:f">
	<c path="lua.Table">
		<c path="foreachi.A"/>
		<c path="foreachi.B"/>
	</c>
	<f a="::">
		<c path="foreachi.A"/>
		<c path="foreachi.B"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></foreachi>
		<sort public="1" params="A:B" set="method" static="1"><f a="table:?order">
	<c path="lua.Table">
		<c path="sort.A"/>
		<c path="sort.B"/>
	</c>
	<f a=":">
		<c path="sort.A"/>
		<c path="sort.A"/>
		<x path="Bool"/>
	</f>
	<x path="Void"/>
</f></sort>
		<insert public="1" params="B" set="method" static="1">
			<f a="table:pos:value">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="insert.B"/>
				</c>
				<x path="Int"/>
				<c path="insert.B"/>
				<x path="Void"/>
			</f>
			<overloads><insert public="1" params="B" set="method"><f a="table:value">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="insert.B"/>
	</c>
	<c path="insert.B"/>
	<x path="Void"/>
</f></insert></overloads>
		</insert>
		<remove public="1" params="B" set="method" static="1">
			<f a="table:?pos">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="remove.B"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads><remove public="1" params="B" set="method"><f a="table">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="remove.B"/>
	</c>
	<x path="Void"/>
</f></remove></overloads>
		</remove>
		<haxe_doc>This library provides generic functions for table manipulation.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G.table"</e></m>
		</meta>
		<haxe_dynamic><c path="lua.Table.B"/></haxe_dynamic>
	</class>
	<typedef path="lua.AnyTable" params="" file="/home/travis/haxe/std/lua/Table.hx" module="lua.Table"><c path="lua.Table">
	<d/>
	<d/>
</c></typedef>
	<class path="lua.TableTools" params="" file="/home/travis/haxe/std/lua/TableTools.hx" extern="1">
		<pack public="1" params="T" set="method" static="1"><f a="args">
	<x path="haxe.extern.Rest"><c path="pack.T"/></x>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="pack.T"/>
	</c>
</f></pack>
		<unpack public="1" params="Int:V" set="method" static="1"><f a="args:?min:?max">
	<c path="lua.Table">
		<c path="unpack.Int"/>
		<c path="unpack.V"/>
	</c>
	<c path="unpack.Int"/>
	<c path="unpack.Int"/>
	<d/>
</f></unpack>
		<maxn public="1" set="method" static="1"><f a="t">
	<t path="lua.AnyTable"/>
	<x path="Int"/>
</f></maxn>
		<haxe_doc>This library provides generic functions for table manipulation.</haxe_doc>
		<meta><m n=":native"><e>"_hx_table"</e></m></meta>
	</class>
	<typedef path="lua.Time" params="" file="/home/travis/haxe/std/lua/Time.hx"><x path="Float"/></typedef>
	<class path="lua.lib.lfs.Lfs" params="" file="/home/travis/haxe/std/lua/lib/lfs/Lfs.hx" extern="1">
		<attributes public="1" set="method" static="1">
			<f a="filepath">
				<c path="String"/>
				<t path="lua.lib.lfs.LfsFileStat"/>
			</f>
			<overloads><attributes public="1" set="method"><f a="filepath:aname">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></attributes></overloads>
		</attributes>
		<chdir public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></chdir>
		<lock_dir public="1" set="method" static="1"><f a="path:?second_stale">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></lock_dir>
		<currentdir public="1" set="method" static="1"><f a=""><c path="String"/></f></currentdir>
		<dir public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<f a=""><c path="String"/></f>
</f></dir>
		<lock public="1" set="method" static="1"><f a="filename:mode:?start:?length">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></lock>
		<link public="1" set="method" static="1"><f a="old:_new:?symlink">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></link>
		<mkdir public="1" set="method" static="1"><f a="dirname">
	<c path="String"/>
	<x path="Bool"/>
</f></mkdir>
		<rmdir public="1" set="method" static="1"><f a="dirname">
	<c path="String"/>
	<x path="Bool"/>
</f></rmdir>
		<setmode public="1" set="method" static="1"><f a="file:mode">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></setmode>
		<symlinkattributes public="1" set="method" static="1"><f a="filepath:?aname">
	<c path="String"/>
	<c path="String"/>
	<c path="lua.Table">
		<c path="String"/>
		<c path="String"/>
	</c>
</f></symlinkattributes>
		<touch public="1" set="method" static="1"><f a="filepath:?atime:?mtime">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></touch>
		<unlock public="1" set="method" static="1"><f a="filehandle:?start:?length">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></unlock>
		<meta><m n=":luaRequire"><e>"lfs"</e></m></meta>
	</class>
	<typedef path="lua.lib.lfs.LfsFileStat" params="" file="/home/travis/haxe/std/lua/lib/lfs/LfsFileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file's owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file's owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all filesystems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File informations, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
</haxe>